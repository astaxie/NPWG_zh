<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Data serialisation</title>
  <link href="../Styles/stylesheet.css" rel="stylesheet" type="text/css" />
  <script src="../toc.js" type="text/javascript">



  //<![CDATA[

   <!-- empty -->
  //]]>
  </script>
  <script type="text/javascript">




  /* <![CDATA[ */
    (function() {
        var s = document.createElement("script"), t = document.getElementsByTagName("script")[0];
        s.type = "text/javascript";
        s.async = true;
        s.src = "http://api.flattr.com/js/0.6/load.js?mode=auto";
        t.parentNode.insertBefore(s, t);
    })();
  /* ]]> */
  </script>
  <style type="text/css">
/*<![CDATA[*/

  body { counter-reset: chapter 4; }

  a.sgc-10 {display:none;}
  span.sgc-9 {color: darkred}
  span.sgc-8 {color: black}
  span.sgc-7 {color: darkmagenta}
  span.sgc-6 {color: green}
  span.sgc-5 {color: blue}
  span.sgc-4 {color: DarkRed}
  span.sgc-3 {color: purple}
  span.sgc-2 {color: firebrick}
  div.sgc-1 {text-align: center}
  /*]]>*/
  </style>
</head>

<body>
  <div class="chapter">
    <h1 id="heading_id_2" class="en">Data serialisation</h1>
    <h1 id="heading_id_2" class="zh">数据序列化</h1>
  </div>



  <div class="preface">
    <p class="en">Communication between a client and a service requires the exchange of data. This data may be highly structured, but has to be serialised for transport. This chapter looks at the basics of serialisation and then considers several techniques supported by Go APIs.</p>
    <p class="zh">客户端与服务之间通过数据交换来进行通信。数据可能是高度结构化的，所以必须被序列化才能用于传输。这一章将研究序列化基础并介绍一些Go API提供的序列化技术。</p>
  </div>

  <div class="generate_from_h2" id="generated-toc"></div>

  <h2 id="heading_id_3" class='en'>Introduction</h2>
  <h2 id="heading_id_3" class='zh'>简介</h2>

  <p class="en">A client and server need to exchange information via messages. TCP and UDP provide the transport mechanisms to do this. The two processes also have to have a protocol in place so that message exchange can take place meaningfully.</p>
  <p class="zh">客户端与服务器需要通过消息来交换信息。TCP与UDP是消息传递的两种机制，在这两种机制之上就需要有合适的协议来约定传输的内容的含义。</p>
  <p class="en">Messages are sent across the network as a sequence of bytes, which has no structure except for a linear stream of bytes. We shall address the various possibilities for messages and the protocols that define them in the next chapter. In this chapter we concentrate on a component of messages - the data that is transferred.</p>
  <p class="zh">在网络上，消息被当作字节序列来传输，它们是没有结构的，仅仅只是一串字节流。我们将在下一章讨论定义消息与协议涉及到的的各种问题。本章，我们只重点关注消息的其中一个方面 - 被传输的数据</p>
  <p class="en">A program will typically build complex data structures to hold the current program state. In conversing with a remote client or service, the program will be attempting to transfer such data structures across the network - that is, outside of the application's own address space.</p>
  <p class="zh">程序通常构造一个复杂的数据结构来保存其自身当前的状态。与远程的客户端或服务的交互中，程序会通过网络将这样的数据结构传输到 -应用程序所在的地址空间之外的地方</p>
  <p class="en">Programming languages use structured data such as</p>
  <p class="zh">编程语言使用的结构化的数据类型有</p>
  <ul class="en">
    <li>records/structures</li>

    <li>variant records</li>

    <li>array - fixed size or varying</li>

    <li>string - fixed size or varying</li>

    <li>tables - e.g. arrays of records</li>

    <li>non-linear structures such as

      <ul class="en">
        <li>circular linked list</li>

        <li>binary tree</li>

        <li>objects with references to other objects</li>
      </ul>
    </li>
  </ul>

<ul class="zh">
    <li>记录/结构</li>

    <li>可变记录</li>

    <li>数组 - 固定大小或可变大小</li>

    <li>字符串 - 固定大小或可变大小</li>

    <li>表 - 例如:记录构成的数组</li>

    <li>非线程结构，比如

      <ul class="en">
        <li>循环链表</li>

        <li>二叉树</li>

        <li>含有其他对象引用的对象</li>
      </ul>
    </li>
  </ul>

  <p class="en">None of IP, TCP or UDP packets know the meaning of any of these data types. All that they can contain is a sequence of bytes. Thus an application has to <em>serialise</em> any data into a stream of bytes in order to write it, and deserialise the stream of bytes back into suitable data structures on reading it. These two operations are known as <em>marshalling</em> and <em>unmarshalling</em> respectively.</p>
  <p class="zh">IP，TCP或者UDP网络包并不知道这些数据类型的含义，它们做的只是包含这些字节序列。因此，写入网络包的时候，应用需要将传输的数据类型 <em>序列化</em> 成字节流，反之，读取网络包的时候，应用需要将字节流<em>反序列化</em>成合适的数据结构，这两个操作被分别称为<em>编组</em>和<em>解组</em>。</p>
  <p class="en">For example, consider sending the following variable length table of two columns of variable length strings:</p>
  <p class="zh">例如:考虑发送如下这样一个由两列可变长度字符串构成的可变长度的表格</p>
  <div class="sgc-1">
    <table border="1">
      <tr>
        <td>fred</td>

        <td>programmer</td>
      </tr>

      <tr>
        <td>liping</td>

        <td>analyst</td>
      </tr>

      <tr>
        <td>sureerat</td>

        <td>manager</td>
      </tr>
    </table>
  </div>

  <p class="en">This could be done by in various ways. For example, suppose that it is known that the data will be an unknown number of rows in a two-column table. Then a marshalled form could be</p>
  <p class="zh">可以通过多种方式来完成。比如：假设知道数据是一个未知行数的两列表格，那么编组形式可能是:</p>
  <pre><code>
    3                // 3 rows, 2 columns assumed
    4 fred           // 4 char string,col 1
    10 programmer    // 10 char string,col 2
    6 liping         // 6 char string, col 1
    7 analyst        // 7 char string, col 2
    8 sureerat       // 8 char string, col 1
    7 manager        // 7 char string, col 2
</code></pre>

  <p class="en">Variable length things can alternatively have their length indicated by terminating them with an "illegal" value, such as '\0' for strings:</p>
  <p class="zh">可变长度的事物都可以通过用一个“非法”的终结值,比如对于字符串来说的'\0',来间接获得它们的长度</p>
  <pre><code>
    3
    fred\0        
    programmer\0
    liping\0
    analyst\0
    sureerat\0
    manager\0
</code></pre>

  <p class="en"> Alternatively, it may be known that the data is a 3-row fixed table of two columns of strings of length 8 and 10 respectively. Then a serialisation could be</p>
  <p class="zh">假设知道数据是一个三行两列且每列长度分别是8或10的表格，那么序列化的结果可能是:<p> 
 <pre><code>
    fred\0\0\0\0
    programmer
    liping\0\0
    analyst\0\0\0
    sureerat
    manager\0\0\0
</code></pre>

  <p class="en"><em>Any of these formats is okay - but the message exchange protocol must specify which one is used, or allow it to be determined at runtime.</em></p>
  <p class="zh"><em>这些格式中的任意一种都是可行的 - 但是消息交换协议必须约定指定使用哪一种，或者约定在运行期再决定。</em></p>
  <h2 id="heading_id_4" class="en">Mutual agreement</h2>
  <h2 id="heading_id_4" class="zh">交互协议</h2>
  <p class="en">The previous section gave an overview of the issue of data serialisation. In practise, the details can be considerably more complex. For example, consider the first possibility, marshalling a table into the stream</p>
  <p class="zh">前一小节总结了在数据序列化过程中可能遇到的各种问题。而在实际操作中，需要考虑的细节还更多一些，例如：先考虑下面这个问题，如何将下面这个表编组成流.</p>
 <pre><code>
    3
    4 fred
    10 programmer
    6 liping
    7 analyst
    8 sureerat
    7 manager
    </code></pre>

  <p class="en">Many questions arise. For example, how many rows are possible for the table - that is, how big an integer do we need to describe the row size? If it is 255 or less, then a single byte will do, but if it is more, then a short, integer or long may be needed. A similar problem occurs for the length of each string. With the characters themselves, to which character set do they belong? 7 bit ASCII? 16 bit Unicode? The question of character sets is discussed at length in a later chapter.</p>
  <p class="zh">许多问题冒出来了。例如：这个表格可能有多少行？- 即我们需要多大的整数来表示表格的大小，如果它只有255行或者更少，那么一个字节就够了，如果更大一些，就可能需要short，integer或者long来表示了。对于字符串的长度也存在同样的问题，对字符本身来说，它们属于哪种字符集? 7位的ASCII？16位的Unicode？字符集的问题将会在后面的章节里详细讨论。</p>

  <p class="en">The above serialisation is <em>opaque</em> or <em>implicit</em>. If data is marshalled using the above format, then there is nothing in the serialised data to say how it should be unmarshalled. The unmarshalling side has to know exactly how the data is serialised in order to unmarshal it correctly. For example, if the number of rows is marshalled as an eight-bit integer, but unmarshalled as a sixteen-bit integer, then an incorrect result will occur as the receiver tries to unmarshall 3 and 4 as a sixteen-bit integer, and the receiving program will almost certainly fail later.</p>
  <p class="zh">上面的序列化是<em>不透明的</em>或者被称为<em>隐式的</em>，如果采用这种格式来编组数据，那么序列化后的数据中没有包含任何信息标示它应该被如何解组。为了正确的解组，解组的一端需要精确的知晓编组的方式。如果数据的行数以8位整型数的方式编组，却以16位整型的方式解组，那么接收者将得到错误的解码结果。比如接受者尝试将3与4当作16位整型解组，肯定会在后续的程序运行的时候失败。</p>

  <p class="en">An early well-known serialisation method is XDR (external data representation) used by Sun's RPC, later known as ONC (Open Network Computing). XDR is defined by RFC 1832 and it is instructive to see how precise this specification is. Even so, XDR is inherently type-unsafe as serialised data contains no type information. The correctness of its use in ONC is ensured primarily by compilers generating code for both marshalling and unmarshalling.</p>
  <p class="zh">早期比较出名的序列化方法是Java使用的XDR(外部资料表示法)，比如被Sun公司的RPC使用。后来就是ONC(开放式网络运算)。XDR由 RFC 1832定义，阅读一下这个规范的详细定义是有意义的，即便如此，由于序列化的数据中不包含类型信息，XDR是天生不安全的。ONC中主要通过由编译器为编、解组生成额外的代码来确保数据的正确性。</p>

  <p class="en">Go contains no explicit support for marshalling or unmarshalling opaque serialised data. The RPC package in Go does not use XDR, but instead uses "gob" serialisation, described later in this chapter.</p>
  <p class="zh">Go没有为编、解组不透明的序列化数据提供显式的支持,标准包中的RPC包也没有使用XDR，而是使用了这一章后面的小节中将要介绍的gob来作为替代方案。</p>

  <h2 id="heading_id_5" class="en">Self-describing data</h2>
  <h2 id="heading_id_5" class="zh">自描述数据</h2>
  <p class="en"> Self-describing data carries type information along with the data. For example, the previous data might get encoded as</p>
  <p class="zh">自描述数据在最终的结果数据中附带了类型信息,例如，前面提到的数据可能被编码为:</p>
  <pre><code>
table
   uint8 3
   uint 2
string
   uint8 4
   []byte fred
string
   uint8 10 
   []byte programmer
string
   uint8 6 
   []byte liping
string
   uint8 7 
   []byte analyst
string
   uint8 8 
   []byte sureerat
string
   uint8 7
   []byte manager
    </code></pre>

  <p class="en">Of course, a real encoding would not normally be as cumbersome and verbose as in the example: small integers would be used as type markers and the whole data would be packed in as small a byte array as possible. (XML provides a counter-example, though.). However, the principle is that the marshaller will generate such type information in the serialised data. The unmarshaller will know the type-generation rules and will be able to use this to reconstruct the correct data structure.</p>
  <p class="zh">当然，实际使用的编码不会如这个例子般啰嗦与累赘。小整数可能被用作类型标记，并且整个数据编码后的字节数组会尽量的小（XML是一个反例）。原则就是编组器会在序列化后的数据中包含类型信息。解组器就会知道类型生成的规则，并使用此规则重组出正确的数据结构。</p>
  <h2 id="heading_id_6" class="en">ASN.1</h2>
  <h2 id="heading_id_6" class="zh">抽象语法表示法</h2>
  <p class="en">Abstract Syntax Notation One (ASN.1) was originally designed in 1984 for the telecommunications industry. ASN.1 is a complex standard, and a subset of it is supported by Go in the package "asn1". It builds self-describing serialised data from complex data structures. Its primary use in current networking systems is as the encoding for X.509 certificates which are heavily used in authentication systems. The support in Go is based on what is needed to read and write X.509 certificates.</p>
  <p class="zh"> 抽象语法表示法/1(ASN.1)最初出现在1984年，它是一个为电信行业设计的复杂标准，Go的标准包asn1实现了它的一个子集，它可以将复杂的数据结构序列化成 自描述的数据。在当前的网络系统中，它主要用于对认证系统中普遍使用的X.509证书的编码。Go对ASN.1的支持主要是X.509证书的读写上。</p>
  <p class="en">Two functions allow us to marshal and unmarshal data</p>
 <p class="zh">以下两个函数用以对数据的编、解组</p>
  <pre><code>
func Marshal(val interface{}) ([]byte, os.Error)
func Unmarshal(val interface{}, b []byte) (rest []byte, err os.Error)
    </code></pre>

  <p class="en">The first marshals a data value into a serialised byte array, and the second unmarshals it. However, the first argument of type <code>interface</code> deserves further examination. Given a variable of a type, we can marshal it by just passing its value. To unmarshal it, we need a variable of a named type that will match the serialised data. The precise details of this are discussed later. But we also need to make sure that the variable is allocated to memory for that type, so that there is actually existing memory for the unmarshalling to write values into.</p>
  <p class="zh">前一个将数据值编组成序列化的字节数组，后一个将其解组出来，需要对<code>interface</code>类型的参数进行更多的类型检查。编组它，我们只需要传递某个类型的变量的值即可，解组它，我们就需要一个与被序列化过的数据匹配的确定类型的变量，这部分的详细细节我们将在后面讨论
。除了有确定类型的变量外，我们同时需要保证那个变量的内存已经被分配，以使被解组后的数据能有实际被写入的地址。</p>
  <p class="en">We illustrate with an almost trivial example, of marshalling and unmarshalling an integer. We can pass an integer value to <code>Marshal</code> to return a byte array, and unmarshal the array into an integer variable as in this program: <!--
. We can find the time from the function
  <code>LocalTime</code> in package "time". We can marshal this
  value directly as type <code>net.Time</code>. To unmarshal,
  we need the address a variable also of that type. BUT: that
  variable must have allocated space, which we can ensure
  by using the operator <code>new</code>. 
--></p>
 <p class="zh">我们将举一个小例子，对一个整数进行编、解组。在这个例子中。我们将一个整数传递给<em>Marshal</em>得到一个字节数组，然后将此数组又解组成一个整数。</p>
  <pre><code><span class="sgc-8">
<span class="sgc-2">/* ASN.1
 */
</span>
<span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"encoding/asn1"</span>
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"os"</span>
)

<span class="sgc-3">func</span> main() {
        mdata, err := asn1.<span class="sgc-5">Marshal</span>(13)
        checkError(err)

        <span class="sgc-3">var</span> n <span class="sgc-6">int</span>
        <span class="sgc-7">_</span>, err1 := asn1.<span class="sgc-5">Unmarshal</span>(mdata, &amp;n)
        checkError(err1)

        fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"After marshal/unmarshal: "</span>, n)
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Fprintf</span>(os.<span class="sgc-5">Stderr</span>, <span class="sgc-4">"Fatal error: %s"</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}
</span></code></pre>

  <p class="en">The unmarshalled value, is of course, 13.</p>
  <p class="zh">当然，被解组后的值，是13</p>

  <p class= "en">Once we move beyond this, things get harder. In order to manage more complex data types, we have to look more closely at the data structures supported by ASN.1, and how ASN.1 support is done in Go.</p>
  <p class="zh">一旦我们越过了这个小关卡，事情开始变得复杂。为了管理更复杂的数据类型，我们需要更深入的了解ASN.1支持的数据类型，以及Go是如何支持ASN.1的。</p>
  <p class="en">Any serialisation method will be able to handle certain data types and not handle some others. So in order to determine the suitability of any serialisation such as ASN.1, you have to look at the possible data types supported versus those you wish to use in your application. The following ASN.1 types are taken from http://www.obj-sys.com/asn1tutorial/node4.html</p>
   <p class="zh">
任何序列化方法都只能处理某些数据类型，其他的数据类型是无法处理的。因此为了评估类似ASN.1等序列化方案的可行性，你必须先将你在程序中要使用的数据类型与它们支持的数据类型做个比较，下面的ASN.1支持的数据类型来自于http://www.obj-sys.com/asn1tutorial/node4.html</p>
  <p class="en"> The simple types are</p>
  <p class="zh"> 简单数据类型有:</p>
  <ul class="en">
    <li>BOOLEAN: two-state variable values</li>

    <li>INTEGER: Model integer variable values</li>

    <li>BIT STRING: Model binary data of arbitrary length</li>

    <li>OCTET STRING: Model binary data whose length is a multiple of eight</li>

    <li>NULL: Indicate effective absence of a sequence element</li>

    <li>OBJECT IDENTIFIER: Name information objects</li>

    <li>REAL: Model real variable values</li>

    <li>ENUMERATED: Model values of variables with at least three states</li>

    <li>CHARACTER STRING: Models values that are strings of characters fro</li>
  </ul>
  <ul class="zh">
    <li>BOOLEAN：两态变量值</li>

    <li>INTEGER：表征整型变量值</li>

    <li>BIT STRING：表征任意长度的二进制数据</li>

    <li>OCT STRING：表征长度是8的倍数的二进制数据</li>

    <li>NULL：指示一个没有有效数据的序列</li>

    <li>OBJECT IDENTIFIER：命名信息对象</li>

    <li>REAL：表征一个real变量值</li>

    <li>ENUMERATED：表征一个至少有三个状态的变量值</li>

    <li>CHARACTER STRING：表征一个字符串值</li>
  </ul>


  <p class="en">Character strings can be from certain character sets</p>
  <p class="zh">字符串可以来自于确定的字符集</p>
  <ul class="en">
    <li>NumericString: 0,1,2,3,4,5,6,7,8,9, and space</li>

    <li>PrintableString: Upper and lower case letters, digits, space, apostrophe, left/right parenthesis, plus sign, comma, hyphen, full stop, solidus, colon, equal sign, question mark</li>

    <li>TeletexString (T61String): The Teletex character set in CCITT's T61, space, and delete</li>

    <li>VideotexString: The Videotex character set in CCITT's T.100 and T.101, space, and delete</li>

    <li>VisibleString (ISO646String): Printing character sets of international ASCII, and space</li>

    <li>IA5String: International Alphabet 5 (International ASCII)</li>

    <li>GraphicString 25 All registered G sets, and space GraphicString</li>
  </ul>

<ul class="zh">
    <li>NumericString: 0,1,2,3,4,5,6,7,8,9, 与空格(space)</li>

    <li>PrintableString: 大、小写字母，数字，空格，省略号，左、右小括号，加号，逗号，连字符，句号，斜线，冒号，等号，问号</li>

    <li>TeletexString(T61String): CCITT的Teletex字符集中的T61，空格和删除(delete)</li>

    <li>VideotexString:CCITT的Videotex字符集中的T.100与T.101, 空格和删除(delete)</li>

    <li>VisibleString (ISO646String):国际ASCII中的打印字符集和空格</li>

    <li>IA5String:国际字母表5(国际ASCII)</li>

    <li>GraphicString:所有被注册的G集和空格</li>
  </ul>

  <p class="en">And finally, there are the structured types:</p>
  <p class="zh">最后,以下是结构化的类型:</p>
  <ul class="en">
    <li>SEQUENCE: Models an ordered collection of variables of different type</li>

    <li>SEQUENCE OF: Models an ordered collection of variables of the same type</li>

    <li>SET: Model an unordered collection of variables of different types</li>

    <li>SET OF: Model an unordered collection of variables of the same type</li>

    <li>CHOICE: Specify a collection of distinct types from which to choose one type</li>

    <li>SELECTION: Select a component type from a specified CHOICE type</li>

    <li>ANY: Enable an application to specify the type Note: ANY is a deprecated ASN.1 Structured Type. It has been replaced with X.680 Open Type.</li>
  </ul>

  <ul class="zh">
    <li>SEQUENCE:表征不同类型变量构成的有序集合</li>

    <li>SEQUENCE OF: 表征相同类型的变量构成的有序集合</li>

    <li>SET: 表征不同类型的变量构成的无序集</li>

    <li>SET OF:表征相同类型的变量构成的有序集合</li>

    <li>CHOICE:从一个不同类型构成的特定集合中选出一个类型</li>

    <li>SELECTION: 从一个特定的CHOICE类型中选取一个组件类型</li>

    <li>ANY:启用一个用以指定类型的应用. 注意:ANY是一个弃用的ASN.1结构类型,它被x.680的 Open Type所替代</li>
  </ul>


  <p class="en">Not all of these are supported by Go. Not all possible values are supported by Go. The rules as given in the Go "asn1" package documentation are</p>
  <p class="zh">不是以上所有的类型，可能的值都被Go支持，在Go 'asn1'包文档中定义的规则如下:</p>
  <ul class="en">
    <li>An ASN.1 INTEGER can be written to an int or int64. If the encoded value does not fit in the Go type, Unmarshal returns a parse error.</li>

    <li>An ASN.1 BIT STRING can be written to a BitString.</li>

    <li>An ASN.1 OCTET STRING can be written to a []byte.</li>

    <li>An ASN.1 OBJECT IDENTIFIER can be written to an ObjectIdentifier.</li>

    <li>An ASN.1 ENUMERATED can be written to an Enumerated.</li>

    <li>An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a *time.Time.</li>

    <li>An ASN.1 PrintableString or IA5String can be written to a string.</li>

    <li>Any of the above ASN.1 values can be written to an interface{}. The value stored in the interface has the corresponding Go type. For integers, that type is int64.</li>

    <li>An ASN.1 SEQUENCE OF x or SET OF x can be written to a slice if an x can be written to the slice's element type.</li>

    <li>An ASN.1 SEQUENCE or SET can be written to a struct if each of the elements in the sequence can be written to the corresponding element in the struct.</li>
  </ul>

  <ul class="zh">
    <li>ASN.1 INTEGER 可以被写入int或者int64中. 如果被编码的值与Go类型不匹配,Unmarshal将返回一个解析错误.</li>

    <li> ASN.1 BIT STRING 可以被写入BitString中.</li>

    <li> ASN.1 OCT STRING可以被写入[]byte中.</li>

    <li>ASN.1 OBJECT IDENTIFIER 可以被写入ObjectIdentifier中.</li>

    <li>ASN.1 ENUMERATED 可以被写入Enumerated中.</li>

    <li>ASN.1 UTCTIME或者GENERALIZEDTIME可以被写入*time.Time中.</li>

    <li>ASN.1 PrintableString 或者 IA5String可以被写入string中.</li>

    <li> 以上的任何ASN.1类型的值都可以作为对应的Go类型的值写入interface{}中。比如整数放入interface{}的话，它对应的类型是int64。</li>

    <li>如果一个变量x可以被当做某个类型写入，那么ASN.1中的x有序列或者x集合就可以当做这个类型的slice写入了。</li>

    <li>如果某个有序列或者集合中的所有元素都可以被写入到某个结构里与之对应的元素中，那么此ASN.1 SEQUENCE 或者SET就可以写入这个结构中。</li>
  </ul>

  <p class="en">Go places real restrictions on ASN.1. For example, ASN.1 allows integers of any size, while the Go implementation will only allow upto signed 64-bit integers. On the other hand, Go distinguishes between signed and unsigned types, while ASN.1 doesn't. So for example, transmitting a value of <code>uint64</code> may fail if it is too large for <code>int64</code>,</p>
  <p class="zh">Go在实现上,为ASN.1添加了一些约束。例如ASN.1允许任意大小的整数,而GO只允许最大为64位有符号整数的值.另一方面，Go区分符号类型与无符号类型,而ASN.1则没有分别.因此传递一个大于<code>int64</code>能表示的最大值的<code>uint64</code>可能会失败。</p>
  
  <p class="en">In a similar vein, ASN.1 allows several different character sets. Go only supports PrintableString and IA5String (ASCII). ASN.1 does not support Unicode characters (which require the BMPString ASN.1 extension). The basic Unicode character set of Go is not supported, and if an application requires transport of Unicode characters, then an encoding such as UTF-7 will be needed. Such encodings are discussed in a later chapter on character sets.</p>
  <p class="zh">同理ASN.1允许多个不同的字符集,而Go只支持PrintableString和IA5String(ASCII). ASN.1不支持Unicode字符(它需要BMPString ASN.1扩展)，Go中的基本Unicode字符集它也不支持，如果应用程序需要传输Unicode字符，则可能需要类似UTF-7的编码。编码相关的内容将会在后边有关字符集的章节来讨论。</p>
  <p class="en">We have seen that a value such as an integer can be easily marshalled and unmarshalled. Other basic types such as booleans and reals can be similarly dealt with. Strings which are composed entirely of ASCII characters can be marshalled and unmarshalled. However, if the string is, for example, "hello \u00bc" which contains the non-ASCII character '¼' then an error will occur: "ASN.1 structure error: PrintableString contains invalid character". This code works, as long as the string is only composed of printable characters:</p>
  <p class="zh">我们已经看到整型的值很容易被编、解组，类似的boolean与real等基本类型处理手法也类似。由ASCII字符构成的字符串也很容易。但对 "hello \u00bc"这样含有 '¼'这个非ASCII字符的字符串，在处理时,则会出现错误：“ASN.1 结构错误:PrintableString包含非法字符”。以下的代码在处理仅由可打印字符（printable characters）构成的字符串时,工作良好。</p>
<pre><code>
        s := "hello"
        mdata, _ := asn1.Marshal(s)

        var newstr string
        asn1.Unmarshal(mdata, &amp;newstr)
    </code></pre>

  <p class="en">ASN.1 also includes some "useful types" not in the above list, such as UTC time. Go supports this UTC time type. This means that you can pass time values in a way that is not possible for other data values. ASN.1 does not support pointers, but Go has special code to manage pointers to time values. The function <code>GetLocalTime</code> returns <code>*time.Time</code>. The special code marshals this, and it can be unmarshalled into a pointer variable to a <code>time.Time</code> object. Thus this code works</p>
  <p class="zh">ASN.1还包含一些未在上边列表中出现的“有用的类型(useful types)”, 比如UTC时间类型，GO支持此UTC时间类型。就是说你可以用一种特有的类型来传递时间值。ASN.1不支持指针,Go中却有指向时间值的指针。比如函数<codem>GetLocalTime</code>返回<code>*time.Time</code>。asn1包编组这个time结构，也是使用这个包解组到一个<code>time.Time</code>对象指针中。代码如下</p>
<pre><code>
        t := time.LocalTime()
        mdata, err := asn1.Marshal(t)

        var newtime = new(time.Time)
        _, err1 := asn1.Unmarshal(&amp;newtime, mdata)
    </code></pre>

  <p class="en">Both <code>LocalTime</code> and <code>new</code> handle pointers to a <code>*time.Time</code>, and Go looks after this special case.</p>
  <p class="zh"><code>LocalTime</code>与<code>new</code>函数都返回的是*time.Time类型的指针，GO将内部对这些特殊类型进行处理。</p>

  <p class="en">In general, you will probably want to marshal and unmarshal structures. Apart from the special case of time, Go will happily deal with structures, but not with pointers to structures. Operations such as <code>new</code> create pointers, so you have to dereference them before marshalling/unmarshalling them. Go normally dereferences pointers for you when needed, but not in this case. These both work for a type <code>T</code>:</p>
  <p class="zh">除了time这种特殊情况外，你可能要编、解组结构类型。除了上面提到的Time结构外，其他的结构Go还是很好处理的。类以<code>new</code>的操作将会创建指针，因此在编、解组之前，你需要解引用它。通常，在你需要的时候，Go会自动对指针进行解引用，但是下面这个例子并不是这么个情况。对于类型T，以下两种方式均可.</p>
<pre><code>
// using variables
var t1 T
t1 = ...
mdata1, _ := asn1.Marshal(t)

var newT1 T
asn1.Unmarshal(&amp;newT1, mdata1)

/// using pointers
var t2 = new(T)
*t2 = ...
mdata2, _ := asn1.Marshal(*t2)

var newT2 = new(T)
asn1.Unmarshal(newT2, mdata2)
    </code></pre>

  <p class="en">Any suitable mix of pointers and variables will work as well.</p>
  <p class="zh">恰当地的使用指针与变量能让代码工作更好。</p>
  <p class="en">The fields of a structure must all be exportable, that is, field names must begin with an uppercase letter. Go uses the <code>reflect</code> package to marshal/unmarshal structures, so it must be able to examine all fields. This type cannot be marshalled:</p>
  <p class="zh">结构的所有字段必须是公共的，即字段名必须以大写字母开头。Go内部实际是使用<code>reflect</code>包来编、解组结构，因此reflect包必须能访问所有的字段。比如下面这个类型是不能被编组的:</p>
 <pre><code>
      type T struct {
          Field1 int
          field2 int // not exportable
      }
    </code></pre>

  <p class="en">ASN.1 only deals with the data types. It does not consider the names of structure fields. So the following type <code>T1</code> can be marshalled/unmarshalled into type <code>T2</code> as the corresponding fields are the same types:</p>
  <p class="zh">ASN.1只处理数据类型，它并不关心结构字段的名字。因此只要对应的字段类型相同那么下面的T1类型将可以被解、解组到T2类型中。</p>
 <pre><code>
type T1 struct {
    F1 int
    F2 string
}

type T2 struct {
    FF1 int
    FF2 string
}
    </code></pre>

  <p class="en">Not only the types of each field must match, but the number must match as well. These two types don't work:</p>
  <p class="zh">不仅每个字段的类型必须匹配，而且字段数目也要相等，下面两个类型将不能互编解码：</p>
  <pre><code>
type T1 struct {
    F1 int
}

type T2 struct {
    F1 int
    F2 string // too many fields
}
    </code></pre>

  <h3 id="heading_id_7" class="en">ASN.1 daytime client and server</h3>
  <h3 id="heading_id_7" class="zh">ASN.1 日期查询服务客户端与服务器</h3>
  <p class="en">Now (finally) let us turn to using ASN.1 to transport data across the network.</p>
  <p class="zh">现在（最后）让我们使用ASN.1来跨网络传输数据</p>
  <p class="en">We can write a TCP server that delivers the current time as an ASN.1 Time type, using the techniques of the last chapter. A server is</p>
   <p class="zh">我们可以使用上一章的技术来编写一个将当前时间作为ASN.Time类型时间来传送的TCP服务器。服务器是:</p>
<pre><code><span class="sgc-8">
<span class="sgc-2">/* ASN1 DaytimeServer
 */
</span><span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"encoding/asn1"</span>
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"net"</span>
        <span class="sgc-4">"os"</span>
        <span class="sgc-4">"time"</span>
)

<span class="sgc-3">func</span> main() {

        service := <span class="sgc-4">":1200"</span>
        tcpAddr, err := net.<span class="sgc-5">ResolveTCPAddr</span>(<span class="sgc-4">"tcp"</span>, service)
        checkError(err)

        listener, err := net.<span class="sgc-5">ListenTCP</span>(<span class="sgc-4">"tcp"</span>, tcpAddr)
        checkError(err)

        <span class="sgc-3">for</span> {
                conn, err := listener.<span class="sgc-5">Accept</span>()
                <span class="sgc-3">if</span> err != nil {
                        <span class="sgc-3">continue</span>
                }

                daytime := time.<span class="sgc-5">Now</span>()
                <span class="sgc-2">// Ignore return network errors.
</span>         mdata, <span class="sgc-7">_</span> := asn1.<span class="sgc-5">Marshal</span>(daytime)
                conn.<span class="sgc-5">Write</span>(mdata)
                conn.<span class="sgc-5">Close</span>() <span class="sgc-2">// we're finished
</span> }
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Fprintf</span>(os.<span class="sgc-5">Stderr</span>, <span class="sgc-4">"Fatal error: %s"</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}
</span></code></pre>

  <p class="en">which can be compiled to an executable such as <code>ASN1DaytimeServer</code> and run with no arguments. It will wait for connections and then send the time as an ASN.1 string to the client.</p>
  <p class="zh">它可以被编译为一个诸如名为<em>ASN1DaytimeServer</em>的可执行程序，运行它不需要任何实际参数，（启动后）它将等待来自客户端的连接，当有新连接后它会将当前时间当作ASN.1字符串传回给客户端.</p>
  <p class="en">A client is</p>
 <p class="zh">客户端代码是</p>
  <pre><code><span class="sgc-8">
<span class="sgc-2">/* ASN.1 DaytimeClient
 */
</span><span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"bytes"</span>
        <span class="sgc-4">"encoding/asn1"</span>
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"io"</span>
        <span class="sgc-4">"net"</span>
        <span class="sgc-4">"os"</span>
        <span class="sgc-4">"time"</span>
)

<span class="sgc-3">func</span> main() {
        <span class="sgc-3">if</span> len(os.<span class="sgc-5">Args</span>) != 2 {
                fmt.<span class="sgc-5">Fprintf</span>(os.<span class="sgc-5">Stderr</span>, <span class="sgc-4">"Usage: %s host:port"</span>, os.<span class="sgc-5">Args</span>[0])
                os.<span class="sgc-5">Exit</span>(1)
        }
        service := os.<span class="sgc-5">Args</span>[1]

        conn, err := net.<span class="sgc-5">Dial</span>(<span class="sgc-4">"tcp"</span>, service)
        checkError(err)

        result, err := readFully(conn)
        checkError(err)

        <span class="sgc-3">var</span> newtime time.<span class="sgc-5">Time</span>
        <span class="sgc-7">_</span>, err1 := asn1.<span class="sgc-5">Unmarshal</span>(result, &amp;newtime)
        checkError(err1)

        fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"After marshal/unmarshal: "</span>, newtime.<span class="sgc-5">String</span>())

        os.<span class="sgc-5">Exit</span>(0)
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Fprintf</span>(os.<span class="sgc-5">Stderr</span>, <span class="sgc-4">"Fatal error: %s"</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}

<span class="sgc-3">func</span> readFully(conn net.<span class="sgc-5">Conn</span>) ([]<span class="sgc-6">byte</span>, error) {
        defer conn.<span class="sgc-5">Close</span>()

        result := bytes.<span class="sgc-5">NewBuffer</span>(nil)
        <span class="sgc-3">var</span> buf [512]<span class="sgc-6">byte</span>
        <span class="sgc-3">for</span> {
                n, err := conn.<span class="sgc-5">Read</span>(buf[0:])
                result.<span class="sgc-5">Write</span>(buf[0:n])
                <span class="sgc-3">if</span> err != nil {
                        <span class="sgc-3">if</span> err == io.<span class="sgc-5">EOF</span> {
                                <span class="sgc-3">break</span>
                        }
                        <span class="sgc-3">return</span> nil, err
                }
        }
        <span class="sgc-3">return</span> result.<span class="sgc-5">Bytes</span>(), nil
}
</span></code></pre>

  <p class="en">This connects to the service given in a form such as <code>localhost:1200</code>, reads the TCP packet and decodes the ASN.1 content back into a string, which it prints.</p>
  <p class="zh">连接字符串形如：<code>localhost:1200</code>。它将读取应答TCP包然后将ASN.1内容解码成字符串并输出。</p>
  <p class="en">We should note that neither of these two - the client or the server - are compatable with the text-based clients and servers of the last chapter. This client and server are exchanging ASN.1 encoded data values, not textual strings.</p>
  <p class="zh">我们应当注意，无论是客户端还是服务器都不与兼容前一章介绍的基于文本的客户端与服务器。此地的客户端与服务器交换的是ASN.1编码的数据值，而非文本串。</p>

  <h2 id="heading_id_8" class="en">JSON</h2>
  <h2 id="heading_id_8" class="zh">JSON</h2>
  <p class="en">JSON stands for JavaScript Object Notation. It was designed to be a lighweight means of passing data between JavaScript systems. It uses a text-based format and is sufficiently general that it has become used as a general purpose serialisation method for many programming languages.</p>
  <p class="zh">JSON全称是JavaScript Object Notation,它是一种应用于JavaScript系统之间传递数据的轻量级格式。它使用基于文本的格式，因为足够通用，现在已经成为了多种编程语言采用的通用的序列化方法了。</p>
  <p class="en">JSON serialises objects, arrays and basic values. The basic values include string, number, boolean values and the null value. Arrays are a comma-separated list of values that can represent arrays, vectors, lists or sequences of various programming languages. They are delimited by square brackets "[ ... ]". Objects are represented by a list of "field: value" pairs enclosed in curly braces "{ ... }".</p>
  <p class="zh">JSON 序列化对象，数组和基本值。基本值包括：字符串，数字，布尔值和NULL值。数组是逗号分割的一组值的列表，可以用来表示各种编程语言中的数组、向量、列表或者序列。它们由方括号来界定，对象则由一个包含在大括号中的"field: values"对构成的列表来表示。</p>
  <p class="en">For example, the table of employees given earlier could be written as an array of employee objects:</p>
  <p class="zh">例如.前面提到过的雇员表可以被编码成如下的一个雇员对象的数组.</p>
  <pre>
<code>
[
   {Name: fred, Occupation: programmer},
   {Name: liping, Occupation: analyst},
   {Name: sureerat, Occupation: manager}
]
</code>
</pre>

  <p class="en">There is no special support for complex data types such as dates, no distinction between number types, no recursive types, etc. JSON is a very simple language, but nevertheless can be quite useful. Its text-based format makes it easy for people to use, even though it has the overheads of string handling.</p>
  <p class="zh">JSON并没有为类似日期这这样的复杂数据类型提供特别的格式支持，也不区分各种数字类型，也没有递归类型等。JSON是一个非常简单但却十分有用的语言，尽管他基于文本的格式在字符传递上开销过多，但是却很适合人类阅读和使用。</p>
  <p class="en">From the Go JSON package specification, marshalling uses the following type-dependent default encodings:</p>
   <p class="zh">从Go JSON包的规范文档可知，JSON包将在编组时使用以下类型相关的默认编码方法：</p>
  <ul class="en">
    <li>Boolean values encode as JSON booleans.</li>

    <li>Floating point and integer values encode as JSON numbers.</li>

    <li>String values encode as JSON strings, with each invalid UTF-8 sequence replaced by the encoding of the Unicode replacement character U+FFFD.</li>

    <li>Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string.</li>

    <li>Struct values encode as JSON objects. Each struct field becomes a member of the object. By default the object's key name is the struct field name converted to lower case. If the struct field has a tag, that tag will be used as the name instead.</li>

    <li>Map values encode as JSON objects. The map's key type must be string; the object keys are used directly as map keys.</li>

    <li>Pointer values encode as the value pointed to. (Note: this allows trees, but not graphs!). A nil pointer encodes as the null JSON object.</li>

    <li>Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON object.</li>

    <li>Channel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an InvalidTypeError.</li>

    <li>JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an infinite recursion.</li>
  </ul>

  <ul class="zh">
    <li>布尔值被编码为JSON的布尔值。</li>

    <li>浮点数与整数被编码为JSON的数字值。</li>

    <li>字符串被编码为JSON的字符串，每一个非法的UTF-8序列将会被UTF8替换符U+FFFD替换。</li>

    <li>数组与Slice会被编码为JSON数组，但是[]byte是会被编码为base64字符串。</li>

    <li>结构体被编码为JSON对象。每一个结构体字段被编码为此对象的对应成员，默认情况下对象的key的名字是对应结构体字段名的小写。如果此字段含有tag，则此tag将是最终对象key的名字。</li>

    <li>map值被编码为JSON对象，此map的key的类型必须是string；map的key直接被当作JSON对象的key。</li>

    <li>指针值被编码为指针所指向的值（注意：此处只允许出现树(tree),而不允许出现图（graph）！）。空指针被编码为空JSON对象.</li>

    <li>接口值被编码为接口实际包含的值。空接口被编码为空JSON对象。</li>

    <li>程道，复数，函数不能被编码为JSON格式。如果尝试这样做，Marshal将会返回一个InvalidTypeError错误。</li>

    <li>JSON不能表示环形数据结构。Go的Marshal函数也不处理它们，将一个环形结构传递给Marshal将会导致死循环。</li>
  </ul>

  <p class="en">A program to store JSON serialised data into a file is</p>
  <p class="zh">将JSON数据存入文件的示例如下:</p>
  <pre><code><span class="sgc-8">
<span class="sgc-2">/* SaveJSON
 */
</span>
<span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"encoding/json"</span>
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"os"</span>
)

<span class="sgc-3">type</span> <span class="sgc-5">Person</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Name</span>  <span class="sgc-5">Name</span>
        <span class="sgc-5">Email</span> []<span class="sgc-5">Email</span>
}

<span class="sgc-3">type</span> <span class="sgc-5">Name</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Family</span>   string
        <span class="sgc-5">Personal</span> string
}

<span class="sgc-3">type</span> <span class="sgc-5">Email</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Kind</span>    string
        <span class="sgc-5">Address</span> string
}

<span class="sgc-3">func</span> main() {
        person := <span class="sgc-5">Person</span>{
                <span class="sgc-5">Name</span>: <span class="sgc-5">Name</span>{<span class="sgc-5">Family</span>: <span class="sgc-4">"Newmarch"</span>, <span class="sgc-5">Personal</span>: <span class="sgc-4">"Jan"</span>},
                <span class="sgc-5">Email</span>: []<span class="sgc-5">Email</span>{<span class="sgc-5">Email</span>{<span class="sgc-5">Kind</span>: <span class="sgc-4">"home"</span>, <span class="sgc-5">Address</span>: <span class="sgc-4">"jan@newmarch.name"</span>},
                        <span class="sgc-5">Email</span>{<span class="sgc-5">Kind</span>: <span class="sgc-4">"work"</span>, <span class="sgc-5">Address</span>: <span class="sgc-4">"j.newmarch@boxhill.edu.au"</span>}}}

        saveJSON(<span class="sgc-4">"person.json"</span>, person)
}

<span class="sgc-3">func</span> saveJSON(fileName string, key <span class="sgc-3">interface</span>{}) {
        outFile, err := os.<span class="sgc-5">Create</span>(fileName)
        checkError(err)
        encoder := json.<span class="sgc-5">NewEncoder</span>(outFile)
        err = encoder.<span class="sgc-5">Encode</span>(key)
        checkError(err)
        outFile.<span class="sgc-5">Close</span>()
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Fatal error "</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}
</span></code></pre>

  <p class="en">and to load it back into memory is</p>
  <p class="zh">可以这样将之重新加载到内存中:</zh>
  <pre><code><span class="sgc-8">
<span class="sgc-2">/* LoadJSON
 */
</span>
<span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"encoding/json"</span>
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"os"</span>
)

<span class="sgc-3">type</span> <span class="sgc-5">Person</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Name</span>  <span class="sgc-5">Name</span>
        <span class="sgc-5">Email</span> []<span class="sgc-5">Email</span>
}

<span class="sgc-3">type</span> <span class="sgc-5">Name</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Family</span>   string
        <span class="sgc-5">Personal</span> string
}

<span class="sgc-3">type</span> <span class="sgc-5">Email</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Kind</span>    string
        <span class="sgc-5">Address</span> string
}

<span class="sgc-3">func</span> (p <span class="sgc-5">Person</span>) <span class="sgc-5">String</span>() string {
        s := p.<span class="sgc-5">Name</span>.<span class="sgc-5">Personal</span> + <span class="sgc-4">" "</span> + p.<span class="sgc-5">Name</span>.<span class="sgc-5">Family</span>
        <span class="sgc-3">for</span> <span class="sgc-7">_</span>, v := range p.<span class="sgc-5">Email</span> {
                s += <span class="sgc-4">"\n"</span> + v.<span class="sgc-5">Kind</span> + <span class="sgc-4">": "</span> + v.<span class="sgc-5">Address</span>
        }
        <span class="sgc-3">return</span> s
}
<span class="sgc-3">func</span> main() {
        <span class="sgc-3">var</span> person <span class="sgc-5">Person</span>
        loadJSON(<span class="sgc-4">"person.json"</span>, &amp;person)

        fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Person"</span>, person.<span class="sgc-5">String</span>())
}

<span class="sgc-3">func</span> loadJSON(fileName string, key <span class="sgc-3">interface</span>{}) {
        inFile, err := os.<span class="sgc-5">Open</span>(fileName)
        checkError(err)
        decoder := json.<span class="sgc-5">NewDecoder</span>(inFile)
        err = decoder.<span class="sgc-5">Decode</span>(key)
        checkError(err)
        inFile.<span class="sgc-5">Close</span>()
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Fatal error "</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}
</span></code></pre>

  <p class="en">The serialised form is (formatted nicely)</p>
  <p class="zh">被序列化后的结果如：（经过了美化处理）</p>
  <pre><code>
{"Name":{"Family":"Newmarch",
         "Personal":"Jan"},
 "Email":[{"Kind":"home","Address":"jan@newmarch.name"},
          {"Kind":"work","Address":"j.newmarch@boxhill.edu.au"}
         ]
}
    </code></pre>

  <h3 id="heading_id_9" class="en">A client and server</h3>
  <h3 id="heading_id_9" class="zh">客户端与服务器</h3>
  <p class="en"> A client to send a person's data and read it back ten times is</p>
  <p class="zh">一个将person数据收发10次的客户端</p>
  <pre><code><span class="sgc-8">
<span class="sgc-2">/* JSON EchoClient
 */
</span><span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"net"</span>
        <span class="sgc-4">"os"</span>
        <span class="sgc-4">"encoding/json"</span>
        <span class="sgc-4">"bytes"</span>
        <span class="sgc-4">"io"</span>
)

<span class="sgc-3">type</span> <span class="sgc-5">Person</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Name</span>  <span class="sgc-5">Name</span>
        <span class="sgc-5">Email</span> []<span class="sgc-5">Email</span>
}

<span class="sgc-3">type</span> <span class="sgc-5">Name</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Family</span>   string
        <span class="sgc-5">Personal</span> string
}

<span class="sgc-3">type</span> <span class="sgc-5">Email</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Kind</span>    string
        <span class="sgc-5">Address</span> string
}

<span class="sgc-3">func</span> (p <span class="sgc-5">Person</span>) <span class="sgc-5">String</span>() string {
        s := p.<span class="sgc-5">Name</span>.<span class="sgc-5">Personal</span> + <span class="sgc-4">" "</span> + p.<span class="sgc-5">Name</span>.<span class="sgc-5">Family</span>
        <span class="sgc-3">for</span> <span class="sgc-7">_</span>, v := range p.<span class="sgc-5">Email</span> {
                s += <span class="sgc-4">"\n"</span> + v.<span class="sgc-5">Kind</span> + <span class="sgc-4">": "</span> + v.<span class="sgc-5">Address</span>
        }
        <span class="sgc-3">return</span> s
}

<span class="sgc-3">func</span> main() {
        person := <span class="sgc-5">Person</span>{
                <span class="sgc-5">Name</span>: <span class="sgc-5">Name</span>{<span class="sgc-5">Family</span>: <span class="sgc-4">"Newmarch"</span>, <span class="sgc-5">Personal</span>: <span class="sgc-4">"Jan"</span>},
                <span class="sgc-5">Email</span>: []<span class="sgc-5">Email</span>{<span class="sgc-5">Email</span>{<span class="sgc-5">Kind</span>: <span class="sgc-4">"home"</span>, <span class="sgc-5">Address</span>: <span class="sgc-4">"jan@newmarch.name"</span>},
                        <span class="sgc-5">Email</span>{<span class="sgc-5">Kind</span>: <span class="sgc-4">"work"</span>, <span class="sgc-5">Address</span>: <span class="sgc-4">"j.newmarch@boxhill.edu.au"</span>}}}

        <span class="sgc-3">if</span> len(os.<span class="sgc-5">Args</span>) != 2 {
                fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Usage: "</span>, os.<span class="sgc-5">Args</span>[0], <span class="sgc-4">"host:port"</span>)
                os.<span class="sgc-5">Exit</span>(1)
        }
        service := os.<span class="sgc-5">Args</span>[1]

        conn, err := net.<span class="sgc-5">Dial</span>(<span class="sgc-4">"tcp"</span>, service)
        checkError(err)

        encoder := json.<span class="sgc-5">NewEncoder</span>(conn)
        decoder := json.<span class="sgc-5">NewDecoder</span>(conn)

        <span class="sgc-3">for</span> n := 0; n &lt; 10; n++ {
                encoder.<span class="sgc-5">Encode</span>(person)
                <span class="sgc-3">var</span> newPerson <span class="sgc-5">Person</span>
                decoder.<span class="sgc-5">Decode</span>(&amp;newPerson)
                fmt.<span class="sgc-5">Println</span>(newPerson.<span class="sgc-5">String</span>())
        }

        os.<span class="sgc-5">Exit</span>(0)
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Fatal error "</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}

<span class="sgc-3">func</span> readFully(conn net.<span class="sgc-5">Conn</span>) ([]<span class="sgc-6">byte</span>, error) {
        defer conn.<span class="sgc-5">Close</span>()

        result := bytes.<span class="sgc-5">NewBuffer</span>(nil)
        <span class="sgc-3">var</span> buf [512]<span class="sgc-6">byte</span>
        <span class="sgc-3">for</span> {
                n, err := conn.<span class="sgc-5">Read</span>(buf[0:])
                result.<span class="sgc-5">Write</span>(buf[0:n])
                <span class="sgc-3">if</span> err != nil {
                        <span class="sgc-3">if</span> err == io.<span class="sgc-5">EOF</span> {
                                <span class="sgc-3">break</span>
                        }
                        <span class="sgc-3">return</span> nil, err
                }
        }
        <span class="sgc-3">return</span> result.<span class="sgc-5">Bytes</span>(), nil
}
</span></code></pre>

  <p class="en">and the corrsponding server is</p>
  <p class="zh">对应的服务器</p>
  <pre><code><span class="sgc-8">
<span class="sgc-2">/* JSON EchoServer
 */
</span><span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"net"</span>
        <span class="sgc-4">"os"</span>
        <span class="sgc-4">"encoding/json"</span>
)

<span class="sgc-3">type</span> <span class="sgc-5">Person</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Name</span>  <span class="sgc-5">Name</span>
        <span class="sgc-5">Email</span> []<span class="sgc-5">Email</span>
}

<span class="sgc-3">type</span> <span class="sgc-5">Name</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Family</span>   string
        <span class="sgc-5">Personal</span> string
}

<span class="sgc-3">type</span> <span class="sgc-5">Email</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Kind</span>    string
        <span class="sgc-5">Address</span> string
}

<span class="sgc-3">func</span> (p <span class="sgc-5">Person</span>) <span class="sgc-5">String</span>() string {
        s := p.<span class="sgc-5">Name</span>.<span class="sgc-5">Personal</span> + <span class="sgc-4">" "</span> + p.<span class="sgc-5">Name</span>.<span class="sgc-5">Family</span>
        <span class="sgc-3">for</span> <span class="sgc-7">_</span>, v := range p.<span class="sgc-5">Email</span> {
                s += <span class="sgc-4">"\n"</span> + v.<span class="sgc-5">Kind</span> + <span class="sgc-4">": "</span> + v.<span class="sgc-5">Address</span>
        }
        <span class="sgc-3">return</span> s
}

<span class="sgc-3">func</span> main() {

        service := <span class="sgc-4">"0.0.0.0:1200"</span>
        tcpAddr, err := net.<span class="sgc-5">ResolveTCPAddr</span>(<span class="sgc-4">"tcp"</span>, service)
        checkError(err)

        listener, err := net.<span class="sgc-5">ListenTCP</span>(<span class="sgc-4">"tcp"</span>, tcpAddr)
        checkError(err)

        <span class="sgc-3">for</span> {
                conn, err := listener.<span class="sgc-5">Accept</span>()
                <span class="sgc-3">if</span> err != nil {
                        <span class="sgc-3">continue</span>
                }

                encoder := json.<span class="sgc-5">NewEncoder</span>(conn)
                decoder := json.<span class="sgc-5">NewDecoder</span>(conn)

                <span class="sgc-3">for</span> n := 0; n &lt; 10; n++ {
                        <span class="sgc-3">var</span> person <span class="sgc-5">Person</span>
                        decoder.<span class="sgc-5">Decode</span>(&amp;person)
                        fmt.<span class="sgc-5">Println</span>(person.<span class="sgc-5">String</span>())
                        encoder.<span class="sgc-5">Encode</span>(person)
                }
                conn.<span class="sgc-5">Close</span>() <span class="sgc-2">// we're finished
</span> }
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Fatal error "</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}
</span></code></pre>

  <h2 id="heading_id_10" class="en">The gob package</h2>
  <h2 id="heading_id_10" class="zh">gob包</h2>
  <p class="en">Gob is a serialisation technique specific to Go. It is designed to encode Go data types specifically and does not at present have support for or by any other languages. It supports all Go data types except for channels, functions and interfaces. It supports integers of all types and sizes, strings and booleans, structs, arrays and slices. At present it has some problems with circular structures such as rings, but that will improve over time.</p>
  <p class="zh">gob是一个Go中特有的序列化技术。它只能编码Go的数据类型，目前它不支持其他语言。它支持除interface，function，channel外的所有的Go数据类型。它支持任何类型和任何大小的整数，还有字符串和布尔值，结构，数组据与切片。目前它在处理ring等环型数据结构方面还存在一些问题，但假以时日，将会得到改善。</p>
  <p class="en">Gob encodes type information into its serialised forms. This is far more extensive than the type information in say an X.509 serialisation, but far more efficient than the type information contained in an XML document. Type information is only included once for each piece of data, but includes, for example, the names of struct fields.</p>
  <p class="zh">Go将类型信息编码到序列化后的表单中，在扩展性方面这远比对应的X.509序列化方法要好。而同时与将类型信息包含在表单中的XML文档相比，则更加高效。对于每个数据，类型信息只包含一次。当然，包含的是字段名称这样的信息。</p>
  <p class="en">This inclusion of type information makes Gob marshalling and unmarshalling fairly robust to changes or differences between the marshaller and unmarshaller. For example, a struct</p>
   <p class="zh">包含类型信息使得Gob在编、解组操作上，当marshaler与unmarshaler不同或者有变化时，具有相当高的健壮性。例如，如下这个结构:</p>
<pre><code>
 struct T {
     a int
     b int
}
    </code></pre>

  <p class="en">can be marshalled and then unmarshalled into a different struct</p>
  <p class="zh">可以被编组并随需解组到不同的结构中.</p>
  <pre><code>
 struct T {
     b int
     a int
}
    </code></pre>

  <p class="en">where the order of fields has changed. It can also cope with missing fields (the values are ignored) or extra fields (the fields are left unchanged). It can cope with pointer types, so that the above struct could be unmarshalled into</p>
  <p class="zh">此处变更了字段的顺序.它也可以处理缺少字段（值将被忽略）或多出字段（此字段原样保持）的情况。它也可以处理指针类型，因此上边的结构可以被解组到下面的结构中.</p>
<pre><code>
 struct T {
     *a int
     **b int
}
    </code></pre>

  <p class="en">To some extent it can cope with type coercions so that an <code>int</code> field can be broadened into an <code>int64</code>, but not with incompatable types such as <code>int</code> and <code>uint</code>.</p>
  <p class="zh">在一定程度上，它也可以强制执行类型转换，比如<code>int<code>字段被扩展成为<code>int64</code>。而对于不兼容类型，比如<code>int</code>与<code>uint</code>,就无能为力了.</p>
  <p class="en">To use Gob to marshall a data value, you first need to create an <code>Encoder</code>. This takes a <code>Writer</code> as parameter and marshalling will be done to this write stream. The encoder has a method <code>Encode</code> which marshalls the value to the stream. This method can be called multiple times on multiple pieces of data. Type information for each data type is only written once, though.</p>
  <p class="zh">为了使用gob编组一个数据值，首先你得创建<code>Encoder</code>。它使用<code>Writer</code>作为参数，编组操作将会将最终结果写入此流中。encoder有个<code>Encode</code>方法，它执行将值编组成流的操作。此方法可以在多份数据上被调用多次。但是对于每一种数据类型，类型信息却只会被写入一次。</p>
  <p class ="en">You use a <code>Decoder</code> to unmarshall the serialised data stream. This takes a <code>Reader</code> and each read returns an unmarshalled data value.</p>
  <p class="zh">你将使用<code>Decoder</code>来执行解组序列化后的数据流的操作。它持有一个<code>Reader</code>参数，每次读取都将返回一个解组后的数据值。</p>
  <p class="en">A program to store gob serialised data into a file is</p>
  <p class="zh">将gob序列化后的数据存入文件的示例程序如下：</p>
  <pre><code><span class="sgc-8">
<span class="sgc-2">/* SaveGob
 */
</span>
<span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"os"</span>
        <span class="sgc-4">"encoding/gob"</span>
)

<span class="sgc-3">type</span> <span class="sgc-5">Person</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Name</span>  <span class="sgc-5">Name</span>
        <span class="sgc-5">Email</span> []<span class="sgc-5">Email</span>
}

<span class="sgc-3">type</span> <span class="sgc-5">Name</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Family</span>   string
        <span class="sgc-5">Personal</span> string
}

<span class="sgc-3">type</span> <span class="sgc-5">Email</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Kind</span>    string
        <span class="sgc-5">Address</span> string
}

<span class="sgc-3">func</span> main() {
        person := <span class="sgc-5">Person</span>{
                <span class="sgc-5">Name</span>: <span class="sgc-5">Name</span>{<span class="sgc-5">Family</span>: <span class="sgc-4">"Newmarch"</span>, <span class="sgc-5">Personal</span>: <span class="sgc-4">"Jan"</span>},
                <span class="sgc-5">Email</span>: []<span class="sgc-5">Email</span>{<span class="sgc-5">Email</span>{<span class="sgc-5">Kind</span>: <span class="sgc-4">"home"</span>, <span class="sgc-5">Address</span>: <span class="sgc-4">"jan@newmarch.name"</span>},
                        <span class="sgc-5">Email</span>{<span class="sgc-5">Kind</span>: <span class="sgc-4">"work"</span>, <span class="sgc-5">Address</span>: <span class="sgc-4">"j.newmarch@boxhill.edu.au"</span>}}}

        saveGob(<span class="sgc-4">"person.gob"</span>, person)
}

<span class="sgc-3">func</span> saveGob(fileName string, key <span class="sgc-3">interface</span>{}) {
        outFile, err := os.<span class="sgc-5">Create</span>(fileName)
        checkError(err)
        encoder := gob.<span class="sgc-5">NewEncoder</span>(outFile)
        err = encoder.<span class="sgc-5">Encode</span>(key)
        checkError(err)
        outFile.<span class="sgc-5">Close</span>()
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Fatal error "</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}
</span></code></pre>

  <p class="en">and to load it back into memory is</p>
  <p class="zh">将之重新加载回内存的操作如下：</p>
  <pre><code><span class="sgc-8">
<span class="sgc-2">/* LoadGob
 */
</span>
<span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"os"</span>
        <span class="sgc-4">"encoding/gob"</span>
)

<span class="sgc-3">type</span> <span class="sgc-5">Person</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Name</span>  <span class="sgc-5">Name</span>
        <span class="sgc-5">Email</span> []<span class="sgc-5">Email</span>
}

<span class="sgc-3">type</span> <span class="sgc-5">Name</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Family</span>   string
        <span class="sgc-5">Personal</span> string
}

<span class="sgc-3">type</span> <span class="sgc-5">Email</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Kind</span>    string
        <span class="sgc-5">Address</span> string
}

<span class="sgc-3">func</span> (p <span class="sgc-5">Person</span>) <span class="sgc-5">String</span>() string {
        s := p.<span class="sgc-5">Name</span>.<span class="sgc-5">Personal</span> + <span class="sgc-4">" "</span> + p.<span class="sgc-5">Name</span>.<span class="sgc-5">Family</span>
        <span class="sgc-3">for</span> <span class="sgc-7">_</span>, v := range p.<span class="sgc-5">Email</span> {
                s += <span class="sgc-4">"\n"</span> + v.<span class="sgc-5">Kind</span> + <span class="sgc-4">": "</span> + v.<span class="sgc-5">Address</span>
        }
        <span class="sgc-3">return</span> s
}
<span class="sgc-3">func</span> main() {
        <span class="sgc-3">var</span> person <span class="sgc-5">Person</span>
        loadGob(<span class="sgc-4">"person.gob"</span>, &amp;person)

        fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Person"</span>, person.<span class="sgc-5">String</span>())
}

<span class="sgc-3">func</span> loadGob(fileName string, key <span class="sgc-3">interface</span>{}) {
        inFile, err := os.<span class="sgc-5">Open</span>(fileName)
        checkError(err)
        decoder := gob.<span class="sgc-5">NewDecoder</span>(inFile)
        err = decoder.<span class="sgc-5">Decode</span>(key)
        checkError(err)
        inFile.<span class="sgc-5">Close</span>()
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Fatal error "</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}
</span></code></pre>

  <h3 id="heading_id_11" class="en">A client and server</h3>
  <h3 id="heading_id_11" class="zh">一个客户端与服务器的例子</h3>
  <p class="en">A client to send a person's data and read it back ten times is</p>
  <p class="zh">一个将person数据收发10次的客户端</p>
  <pre><code><span class="sgc-8">
<span class="sgc-2">/* Gob EchoClient
 */
</span><span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"net"</span>
        <span class="sgc-4">"os"</span>
        <span class="sgc-4">"encoding/gob"</span>
        <span class="sgc-4">"bytes"</span>
        <span class="sgc-4">"io"</span>
)

<span class="sgc-3">type</span> <span class="sgc-5">Person</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Name</span>  <span class="sgc-5">Name</span>
        <span class="sgc-5">Email</span> []<span class="sgc-5">Email</span>
}

<span class="sgc-3">type</span> <span class="sgc-5">Name</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Family</span>   string
        <span class="sgc-5">Personal</span> string
}

<span class="sgc-3">type</span> <span class="sgc-5">Email</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Kind</span>    string
        <span class="sgc-5">Address</span> string
}

<span class="sgc-3">func</span> (p <span class="sgc-5">Person</span>) <span class="sgc-5">String</span>() string {
        s := p.<span class="sgc-5">Name</span>.<span class="sgc-5">Personal</span> + <span class="sgc-4">" "</span> + p.<span class="sgc-5">Name</span>.<span class="sgc-5">Family</span>
        <span class="sgc-3">for</span> <span class="sgc-7">_</span>, v := range p.<span class="sgc-5">Email</span> {
                s += <span class="sgc-4">"\n"</span> + v.<span class="sgc-5">Kind</span> + <span class="sgc-4">": "</span> + v.<span class="sgc-5">Address</span>
        }
        <span class="sgc-3">return</span> s
}

<span class="sgc-3">func</span> main() {
        person := <span class="sgc-5">Person</span>{
                <span class="sgc-5">Name</span>: <span class="sgc-5">Name</span>{<span class="sgc-5">Family</span>: <span class="sgc-4">"Newmarch"</span>, <span class="sgc-5">Personal</span>: <span class="sgc-4">"Jan"</span>},
                <span class="sgc-5">Email</span>: []<span class="sgc-5">Email</span>{<span class="sgc-5">Email</span>{<span class="sgc-5">Kind</span>: <span class="sgc-4">"home"</span>, <span class="sgc-5">Address</span>: <span class="sgc-4">"jan@newmarch.name"</span>},
                        <span class="sgc-5">Email</span>{<span class="sgc-5">Kind</span>: <span class="sgc-4">"work"</span>, <span class="sgc-5">Address</span>: <span class="sgc-4">"j.newmarch@boxhill.edu.au"</span>}}}

        <span class="sgc-3">if</span> len(os.<span class="sgc-5">Args</span>) != 2 {
                fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Usage: "</span>, os.<span class="sgc-5">Args</span>[0], <span class="sgc-4">"host:port"</span>)
                os.<span class="sgc-5">Exit</span>(1)
        }
        service := os.<span class="sgc-5">Args</span>[1]

        conn, err := net.<span class="sgc-5">Dial</span>(<span class="sgc-4">"tcp"</span>, service)
        checkError(err)

        encoder := gob.<span class="sgc-5">NewEncoder</span>(conn)
        decoder := gob.<span class="sgc-5">NewDecoder</span>(conn)

        <span class="sgc-3">for</span> n := 0; n &lt; 10; n++ {
                encoder.<span class="sgc-5">Encode</span>(person)
                <span class="sgc-3">var</span> newPerson <span class="sgc-5">Person</span>
                decoder.<span class="sgc-5">Decode</span>(&amp;newPerson)
                fmt.<span class="sgc-5">Println</span>(newPerson.<span class="sgc-5">String</span>())
        }

        os.<span class="sgc-5">Exit</span>(0)
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Fatal error "</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}

<span class="sgc-3">func</span> readFully(conn net.<span class="sgc-5">Conn</span>) ([]<span class="sgc-6">byte</span>, error) {
        defer conn.<span class="sgc-5">Close</span>()

        result := bytes.<span class="sgc-5">NewBuffer</span>(nil)
        <span class="sgc-3">var</span> buf [512]<span class="sgc-6">byte</span>
        <span class="sgc-3">for</span> {
                n, err := conn.<span class="sgc-5">Read</span>(buf[0:])
                result.<span class="sgc-5">Write</span>(buf[0:n])
                <span class="sgc-3">if</span> err != nil {
                        <span class="sgc-3">if</span> err == io.<span class="sgc-5">EOF</span> {
                                <span class="sgc-3">break</span>
                        }
                        <span class="sgc-3">return</span> nil, err
                }
        }
        <span class="sgc-3">return</span> result.<span class="sgc-5">Bytes</span>(), nil
}
</span></code></pre>

  <p class="en">and the corrsponding server is</p>
  <p class="zh">对应的服务器：</p>
  <pre><code><span class="sgc-8">
<span class="sgc-2">/* Gob EchoServer
 */
</span><span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"fmt"</span>
        <span class="sgc-4">"net"</span>
        <span class="sgc-4">"os"</span>
        <span class="sgc-4">"encoding/gob"</span>
)

<span class="sgc-3">type</span> <span class="sgc-5">Person</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Name</span>  <span class="sgc-5">Name</span>
        <span class="sgc-5">Email</span> []<span class="sgc-5">Email</span>
}

<span class="sgc-3">type</span> <span class="sgc-5">Name</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Family</span>   string
        <span class="sgc-5">Personal</span> string
}

<span class="sgc-3">type</span> <span class="sgc-5">Email</span> <span class="sgc-3">struct</span> {
        <span class="sgc-5">Kind</span>    string
        <span class="sgc-5">Address</span> string
}

<span class="sgc-3">func</span> (p <span class="sgc-5">Person</span>) <span class="sgc-5">String</span>() string {
        s := p.<span class="sgc-5">Name</span>.<span class="sgc-5">Personal</span> + <span class="sgc-4">" "</span> + p.<span class="sgc-5">Name</span>.<span class="sgc-5">Family</span>
        <span class="sgc-3">for</span> <span class="sgc-7">_</span>, v := range p.<span class="sgc-5">Email</span> {
                s += <span class="sgc-4">"\n"</span> + v.<span class="sgc-5">Kind</span> + <span class="sgc-4">": "</span> + v.<span class="sgc-5">Address</span>
        }
        <span class="sgc-3">return</span> s
}

<span class="sgc-3">func</span> main() {

        service := <span class="sgc-4">"0.0.0.0:1200"</span>
        tcpAddr, err := net.<span class="sgc-5">ResolveTCPAddr</span>(<span class="sgc-4">"tcp"</span>, service)
        checkError(err)

        listener, err := net.<span class="sgc-5">ListenTCP</span>(<span class="sgc-4">"tcp"</span>, tcpAddr)
        checkError(err)

        <span class="sgc-3">for</span> {
                conn, err := listener.<span class="sgc-5">Accept</span>()
                <span class="sgc-3">if</span> err != nil {
                        <span class="sgc-3">continue</span>
                }

                encoder := gob.<span class="sgc-5">NewEncoder</span>(conn)
                decoder := gob.<span class="sgc-5">NewDecoder</span>(conn)

                <span class="sgc-3">for</span> n := 0; n &lt; 10; n++ {
                        <span class="sgc-3">var</span> person <span class="sgc-5">Person</span>
                        decoder.<span class="sgc-5">Decode</span>(&amp;person)
                        fmt.<span class="sgc-5">Println</span>(person.<span class="sgc-5">String</span>())
                        encoder.<span class="sgc-5">Encode</span>(person)
                }
                conn.<span class="sgc-5">Close</span>() <span class="sgc-2">// we're finished
</span> }
}

<span class="sgc-3">func</span> checkError(err error) {
        <span class="sgc-3">if</span> err != nil {
                fmt.<span class="sgc-5">Println</span>(<span class="sgc-4">"Fatal error "</span>, err.<span class="sgc-5">Error</span>())
                os.<span class="sgc-5">Exit</span>(1)
        }
}
</span></code></pre>

  <h2 id="heading_id_12" class="en">Encoding binary data as strings</h2>
  <h2 id="heading_id_12" class="zh">将二进制数据编码为字符串</h2>
  <p class="en">Once upon a time, transmtting 8-bit data was problematic. It was often transmitted over noisy serial lines and could easily become corrupted. 7-bit data on the other hand could be transmitted more reliably because the 8th bit could be used as check digit. For example, in an "even parity" scheme, the check digit would be set to one or zero to make an even number of 1's in a byte. This allows detection of errors of a single bit in each byte.</p>
  <p class="zh">以前，传输8-bit数据总是会出现各种问题。它通常由充满噪声的串行线来输入，因此会出错。因为第8个比特位可以被用来做数字检验，所以7-bit的传输要值得信任一些。例如在 “偶数奇偶校检”模式下，为了让一个字节中出现偶数个1,校检位可以被设置1或0，这将可侦测每个字节中的单个bit位出现的错误.</p>
  <p class="en">ASCII is a 7-bit character set. A number of schemes have been developed that are more sophisticated than simple parity checking, but which involve translating 8-bit binary data into 7-bit ASCII format. Essentially, the 8-bit data is stretched out in some way over the 7-bit bytes.</p>
  <p class="zh">ASCII是一种7-bit字符集。很多比‘奇偶检验’精巧的模式被开发出来，但是本质上都是将8-bit二进制数据转化成7-bit ASCII格式。本质上8-bit数据是7-bit数据的延伸。</p>
  <p class="en">Binary data transmitted in HTTP responses and requests is often translated into an ASCII form. This makes it easy to inspect the HTTP messages with a simple text reader without worrying about what strange 8-bit bytes might do to your display!</p>
  <p class="zh">在HTTP的请求与应答中，二进制数据常被转化为ASCII的形式。这使得通过一个简单的文本阅读器来检视HTT消息变得容易，而不需要担心8-bit字节造成的显示乱码的问题！</p>
  <p class="en">One common format is Base64. Go has support for many binary-to-text formats, including base64.</p>
  <p class="zh">一个通用的格式是Base64，Go支持包括base64在内的多种binary-to-text格式.</p>

  <p class="en">There are two principal functions to use for Base64 encoding and decoding:</p>
  <p class="zh">两个编、解码Base64的主要函数:</p>

  <pre>
<code>
func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser
func NewDecoder(enc *Encoding, r io.Reader) io.Reader
</code>
</pre>

  <p class="en">A simple program just to encode and decode a set of eight binary digits is</p>
  <p class="zh">一个用以演示编解码8位二进制数的简单程序如下:</p>
  <pre><code><span class="sgc-8">
<span class="sgc-9">/**
 * Base64
 */
</span>
<span class="sgc-3">package</span> main

<span class="sgc-3">import</span> (
        <span class="sgc-4">"bytes"</span>
        <span class="sgc-4">"encoding/base64"</span>
        <span class="sgc-4">"fmt"</span>
)

<span class="sgc-3">func</span> main() {

        eightBitData := []<span class="sgc-6">byte</span>{1, 2, 3, 4, 5, 6, 7, 8}
        bb := &amp;bytes.<span class="sgc-5">Buffer</span>{}
        encoder := base64.<span class="sgc-5">NewEncoder</span>(base64.<span class="sgc-5">StdEncoding</span>, bb)
        encoder.<span class="sgc-5">Write</span>(eightBitData)
        encoder.<span class="sgc-5">Close</span>()
        fmt.<span class="sgc-5">Println</span>(bb)

        dbuf := make([]<span class="sgc-6">byte</span>, 12)
        decoder := base64.<span class="sgc-5">NewDecoder</span>(base64.<span class="sgc-5">StdEncoding</span>, bb)
        decoder.<span class="sgc-5">Read</span>(dbuf)
        <span class="sgc-3">for</span> <span class="sgc-7">_</span>, ch := range dbuf {
                fmt.<span class="sgc-5">Print</span>(ch)
        }
}
</span></code></pre>

  <p>Copyright Jan Newmarch, jan@newmarch.name</p>

  <p>If you like this book, please contribute using Flattr <a class="FlattrButton sgc-10" href="http://jan.newmarch.name/go/index.html"></a><br />
  or donate using PayPal</p>

  <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
    <input name="cmd" type="hidden" value="_s-xclick" /> <input name="encrypted" type="hidden" value="-----BEGIN PKCS7-----MIIHLwYJKoZIhvcNAQcEoIIHIDCCBxwCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYCCw7fVj6fuHxYMvE0PBlURcRgBFb1s4TxTUDgsS6BgkdJPt2GF8NFPNvE/oFvPNY2jBGrXSIkxCr9dFYzraKC8csPASWb0z9l8swwbIHWgrvb5cuaVuLbtRzesh94sqyh9MmZ5U1xcMrMtlw1S60gK5lPbKPsXzcY74brjt44J7jELMAkGBSsOAwIaBQAwgawGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQIAXtre9K+AiWAgYiJVN0CmxAPscp0u0O8R0mD+cNz/Fe3lNIrqqMPplkri20WbbVxhbRwJTjtOxcLMbmSIeC8oWh14aSy9Jptgm1wNlQYADQQUgMnR/qIlYgHmXjJ4C6wZteqNVJn+RKfM/tS008Ola5SJABaGe9BmRSQCjMKqEyqm3Mx2hoLeWMXeyoMaW3Xteg6oIIDhzCCA4MwggLsoAMCAQICAQAwDQYJKoZIhvcNAQEFBQAwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMB4XDTA0MDIxMzEwMTMxNVoXDTM1MDIxMzEwMTMxNVowgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDBR07d/ETMS1ycjtkpkvjXZe9k+6CieLuLsPumsJ7QC1odNz3sJiCbs2wC0nLE0uLGaEtXynIgRqIddYCHx88pb5HTXv4SZeuv0Rqq4+axW9PLAAATU8w04qqjaSXgbGLP3NmohqM6bV9kZZwZLR/klDaQGo1u9uDb9lr4Yn+rBQIDAQABo4HuMIHrMB0GA1UdDgQWBBSWn3y7xm8XvVk/UtcKG+wQ1mSUazCBuwYDVR0jBIGzMIGwgBSWn3y7xm8XvVk/UtcKG+wQ1mSUa6GBlKSBkTCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb22CAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQCBXzpWmoBa5e9fo6ujionW1hUhPkOBakTr3YCDjbYfvJEiv/2P+IobhOGJr85+XHhN0v4gUkEDI8r2/rNk1m0GA8HKddvTjyGw/XqXa+LSTlDYkqI8OwR8GEYj4efEtcRpRYBxV8KxAW93YDWzFGvruKnnLbDAF6VR5w/cCMn5hzGCAZowggGWAgEBMIGUMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbQIBADAJBgUrDgMCGgUAoF0wGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTEwNTAyMDcwNzQ1WjAjBgkqhkiG9w0BCQQxFgQUgvHyq74JT8DnmViqEqG5KpIW0cAwDQYJKoZIhvcNAQEBBQAEgYAzycmlaZMZjkmYniVBUVTQeywigBo+80toDP2g9+yCzO4mG1Abmfcr/S1XdT8djFA9w37F+F+nSkP857evscUhns30c9wYuPoiNudkJMOkYegqyq+EI4AMNGPuQNZ+4vznmqTgFTn9iQjONC8NGQ/0GuCCQ/AqJZs/0ZiWivlPhA==-----END PKCS7----- " /> <input alt="PayPal - The safer, easier way to pay online." border="0" name="submit" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_AU/i/btn/btn_donateCC_LG.gif" type="image" /> <img alt="" border="0" height="1" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_AU/i/scr/pixel.gif" width="1" />
  </form>
</body>
</html>
