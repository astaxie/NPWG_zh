<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Sockets</title>
  <link href="../Styles/stylesheet.css" rel="stylesheet" type="text/css" />
  <script src="../toc.js" type="text/javascript">



  //<![CDATA[

   <!-- empty -->
  //]]>
  </script>
  <script type="text/javascript">




  /* <![CDATA[ */
    (function() {
        var s = document.createElement("script"), t = document.getElementsByTagName("script")[0];
        s.type = "text/javascript";
        s.async = true;
        s.src = "http://api.flattr.com/js/0.6/load.js?mode=auto";
        t.parentNode.insertBefore(s, t);
    })();
  /* ]]> */
  </script>
  <style type="text/css">
/*<![CDATA[*/

  body { counter-reset: chapter 3; }

  body {
  background-color: #FFFFFF;
  }
  a.sgc-8 {display:none;}
  span.sgc-7 {color: green}
  span.sgc-6 {color: darkmagenta}
  span.sgc-5 {color: black}
  span.sgc-4 {color: blue}
  span.sgc-3 {color: DarkRed}
  span.sgc-2 {color: purple}
  span.sgc-1 {color: firebrick}
  /*]]>*/
  </style>
</head>

<body>
  <div class="chapter">
    <h1 id="heading_id_2" class="en">Socket-level Programming</h1>
    <h1 id="heading_id_2" class="zh">套接字级编程</h1>
  </div>

  <div class="preface">
    <p class="en">This chapter looks at the basic techniques for network programming. It deals with host and service addressing, and then considers TCP and UDP. It shows how to build both servers and clients using the TCP and UDP Go APIs. It also looks at raw sockets, in case you need to implement your own protocol above IP.</p>
    <p class="zh">本章将着眼于网络编程的基础方法，将涉及到主机和服务寻址，也会考虑到TCP和UDP。同时也将展示如何使用GO的TCP和UDP相关的API来构建服务器和客户端。最后介绍了原生套接字，如果你需要基于IP协议实现你自己的协议的话。</p>
  </div>

  <div class="generate_from_h2" id="generated-toc"></div>

  <h2 id="heading_id_3" class="en">Introduction</h2>
  <h2 id="heading_id_3" class="zh">介绍</h2>

  <p class="en">There are many kinds of networks in the world. These range from the very old such as serial links, through to wide area networks made from copper and fibre, to wireless networks of various kinds, both for computers and for telecommunications devices such as phones. These networks obviously differ at the physical link layer, but in many cases they also differed at higher layers of the OSI stack.</p>
  <p class="zh">世上存在很多种网络。它们涵盖了从古老如串行链路，到为计算机或手机这样的通讯设备所搭建的铜缆和光纤的广域网，或各种各样的无线网络。在物理链路层它们区别明显，但很多时候，在更高层次的OSI模型它们也存在差异。</p>

  <p class="en">Over the years there has been a convergence to the "internet stack" of IP and TCP/UDP. For example, Bluetooth defines physical layers and protocol layers, but on top of that is an IP stack so that the same internet programming techniques can be employed on many Bluetooth devices. Similarly, developing 4G wireless phone technologies such as LTE (Long Term Evolution) will also use an IP stack.</p>
  <p class="zh">多年的发展，使得IP和TCP/UDP协议基本上就等价于网络协议栈。例如, 蓝牙定义了物理层和协议层，但最重要的是IP协议栈，可以在许多蓝牙设备使相同的互联网编程技术。同样, 开发4G无线手机技术，如LTE（Long Term Evolution）也将使用IP协议栈。</p>

  <p class="en">While IP provides the networking layer 3 of the OSI stack, TCP and UDP deal with layer 4. These are not the final word, even in the interenet world: SCTP has come from the telecommunications to challenge both TCP and UDP, while to provide internet services in interplanetary space requires new, under development protocols such as DTN. Nevertheless, IP, TCP and UDP hold sway as principal networking technologies now and at least for a considerable time into the future. Go has full support for this style of programming</p>
  <p class="zh">IP提供了第3层的OSI网络协议栈，TCP和UDP则提供了第4层。即使在因特网世界，这些都不是固定不变的：TCP和UDP将面临来自SCTP（STREAM CONTROL TRANSMISSION PROTOCOL 流控制传输协议）的挑战，同时在星际空间中提供互联网服务需要新的像正在开发的DTN协议。不过，IP, TCP和UDP至少在当前甚至未来相当长的时间内是主要的网络技术。Go语言提供了对这种编程的全面支持。</p>

  <p class="en">This chapter shows how to do TCP and UDP programming using Go, and how to use a raw socket for other protocols.</p>
  <p class="zh">本章介绍如何使用GO编写TCP和UDP程序，以及如何使用其他协议的原始套接字。</p>

  <h2 id="heading_id_4" class="en">The TCP/IP stack</h2>
  <h2 id="heading_id_4" class="zh">TCP/IP协议栈</h2>

  <p class="en">The OSI model was devised using a committee process wherein the standard was set up and then implemented. Some parts of the OSI standard are obscure, some parts cannot easily be implemented, some parts have not been implemented.</p>
  <p class="zh">OSI模型标准的建立和实施是一个委员会（国际标准化组织ISO--译者注）设计的。OSI标准中的一些部分是模糊的，有些部件不能很容易地实现，一些地方还没有得到落实。</p>

  <p class="en">The TCP/IP protocol was devised through a long-running DARPA project. This worked by implementation followed by RFCs (Request For Comment). TCP/IP is the principal Unix networking protocol. TCP/IP = Transmission Control Protocol/Internet Protocol.</p>
  <p class="zh">TCP/IP协议由长期运行的一个DARPA（美国国防先进研究项目局）项目设计。该工作其次由RFC (Request For Comment)实施。TCP/IP是Unix的首要网络协议。TCP/IP等于传输控制协议/互联网协议。</p>

  <p class="en">The TCP/IP stack is shorter than the OSI one:<br />
  <img alt="" src="../Images/tcp_stack.gif" /><br />
  TCP is a connection-oriented protocol, UDP (User Datagram Protocol) is a connectionless protocol.</p>
  <p class="zh">TCP/IP协议栈是OSI模型的一部分：<br />
  <img alt="" src="../Images/tcp_stack.gif" /><br />
  TCP是一个面向连接的协议，UDP（User Datagram Protocol，用户数据报协议）是一种无连接的协议。</p>

  <h3 id="heading_id_5" class="en">IP datagrams</h3>
  <h3 id="heading_id_5" class="zh">IP数据包</h3>

  <p class="en">The IP layer provides a connectionless and unreliable delivery system. It considers each datagram independently of the others. Any association between datagrams must be supplied by the higher layers.</p>
  <p class="zh">IP层提供了无连接的不可靠的传输系统，任何数据包之间的关联必须依赖更高的层来提供。</p>

  <p class="en">The IP layer supplies a checksum that includes its own header. The header includes the source and destination addresses.</p>
  <p class="zh">IP层包头支持数据校验，在包头包括源地址和目的地址。</p>

  <p class="en">The IP layer handles routing through an Internet. It is also responsible for breaking up large datagrams into smaller ones for transmission and reassembling them at the other end.</p>
  <p class="zh">IP层通过路由连接到因特网，还负责将大数据包分解为更小的包，并传输到另一端后进行重组。</p>

  <h3 id="heading_id_6">UDP</h3>

  <p class="en">UDP is also connectionless and unreliable. What it adds to IP is a checksum for the contents of the datagram and <i>port numbers.</i> These are used to give a client/server model - see later.</p>
  <p class="zh">UDP是无连接的，不可靠的。它包括IP数据报的内容和<i>端口号</i>的校验。在后面，我们会用它来构建一些客户端/服务器例子。</p>

  <h3 id="heading_id_7">TCP</h3>

  <p class="en">TCP supplies logic to give a reliable connection-oriented protocol above IP. It provides a <i>virtual circuit</i> that two processes can use to communicate. It also uses port numbers to identify services on a host.</p>
  <p class="zh">TCP是构建于IP之上的面向链接的协议。它提供了一个<i>虚电路</i>使得两个应用进程可以通过它来通信。它通过端口号来识别主机上的服务。</p>

  <h2 id="heading_id_8" class="en">Internet addresses</h2>
  <h2 id="heading_id_8" class="zh">互联网地址</h2>

  <p class="en">In order to use a service you must be able to find it. The Internet uses an address scheme for devices such as computers so that they can be located. This addressing scheme was originally devised when there were only a handful of connected computers, and very generously allowed upto 2^32 addresses, using a 32 bit unsigned integer. These are the so-called IPv4 addresses. In recent years, the number of connected (or at least directly addressable) devices has threatened to exceed this number, and so "any day now" we will switch to IPv6 addressing which will allow upto 2^128 addresses, using an unsigned 128 bit integer. The changeover is most likely to be forced by emerging countries, as the developed world has already taken nearly all of the pool of IPv4 addresses.</p>
  <p class="zh">要想使用一项服务，你必须先能找到它。互联网使用地址表来定位设备，例如计算机。这种寻址方案最初被设计出来只允许极少数的计算机连接上，使用32位无符号整形，拥有多达2^32个地址。这就是我们所说的IPv4地址。近年来，连接到互联网（至少可以直接寻址）的设备的数量有超过这个数量的趋势，所以在不久的将来我们将会过渡到IPv6寻址，它使用128位无符号整数，且允许存在多达2^128个的地址。这种转变很有可能由新兴国家推动，因为发达国家已几乎耗尽IPv4地址池。</p>

  <h3 id="heading_id_9" class="en">IPv4 addresses</h3>
  <h3 id="heading_id_9" class="zh">IPv4地址</h3>

  <p class="en">The address is a 32 bit integer which gives the IP address. This addresses down to a network interface card on a single device. The address is usually written as four bytes in decimal with a dot '.' between them, as in "127.0.0.1" or "66.102.11.104".</p>
  <p class="zh">IP地址是一个32位整数构成。每个设备的网络接口都有一个地址。该地址通常使用'.'符号分割的4字节的十进制数，例如："127.0.0.1" 或 "66.102.11.104"。</p>

  <p class="en">The IP address of any device is generally composed of two parts: the address of the network in which the device resides, and the address of the device within that network. Once upon a time, the split between network address and internal address was simple and was based upon the bytes used in the IP address.</p>
  <p class="zh">所有设备的IP地址，通常是由两部分组成：网络地址和主机地址。从前，网络地址和主机地址的区分方法很简单，是根据IP地址中的字节来区分的。</p>

  <ul class="en">
    <li>In a class A network, the first byte identifies the network, while the last three identify the device. There are only 128 class A networks, owned by the very early players in the internet space such as IBM, the General Electric Company and MIT (http://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xml)</li>

    <li>Class B networks use the first two bytes to identify the network and the last two to identify devices within the subnet. This allows upto 2^16 (65,536) devices on a subnet</li>

    <li>Class C networks use the first three bytes to identify the network and the last one to identify devices within that network. This allows upto 2^8 (actually 254, not 256) devices</li>
  </ul>
  <ul class="zh">
    <li>一个A类网络，前1个字节标识为网络地址，同时后3字节标识为主机地址。A类网络只有128个, 被很早的互联网成员例如IBM，通用电气公司(the General Electric Company)和MIT所拥有。(http://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xml)</li>

    <li>一个B类网络使用前2个字节标识为网络地址，后2字节标识为子网的主机地址。这最多允许2^16 (65,536)个设备在同一个子网。</li>

    <li>一个C类网络使用前3字节标识为网络地址，后1字节的主机地址。这最多允许2^8 (其实是254, 不是256)个设备。</li>
  </ul>

  <p class="en">This scheme doesn't work well if you want, say, 400 computers on a network. 254 is too small, while 65,536 is too large. In binary arithmetic terms, you want about 512. This can be achieved by using a 23 bit network address and 9 bits for the device addresses. Similarly, if you want upto 1024 devices, you use a 22 bit network address and a 10 bit device address.</p>
  <p class="zh">但是，比如你需要400台计算机在同一个网络，该方案是不可行的。254太小，而65,536又太大。根据二进制计算，你大约需要512(2^9，译者注)。这样就可以通过使用一个23位的网络地址和9位的主机地址实现。同样，如果你需要多达1024台设备，可以使用一个22位网络地址和一个10位的主机地址。</p>
  
  <p class="en">Given an IP address of a device, and knowing how many bits N are used for the network address gives a relatively straightforward process for extracting the network address and the device address within that network. Form a "network mask" which is a 32-bit binary number with all ones in the first N places and all zeroes in the remaining ones. For example, if 16 bits are used for the network address, the mask is 11111111111111110000000000000000. It's a little inconvenient using binary, so decimal bytes are usually used. The netmask for 16 bit network addresses is 255.255.0.0, for 24 bit network addresses it is 255.255.255.0, while for 23 bit addresses it would be 255.255.254.0 and for 22 bit addresses it would be 255.255.252.0.</p>
  <p class="zh">给定一个IP地址，并且已知N比特位用于网络地址，那么可以直接提取出这个网络中的网络地址和主机地址。那么一个前面N位为1，其他所有位为0的32位二进制数就是“网络掩码”。例如，如果使用16位的网络地址，掩码为11111111111111110000000000000000。使用二进制有一点不方便，所以通常使用十进制表示。16位网络地址的子网掩码是255.255.0.0，而对于23位地址，这将是255.255.254.0，和22位地址，这将是255.255.252.0。</p>
  
  <p class="en">Then to find the network of a device, bit-wise AND it's IP address with the network mask, while the device address within the subnet is found with bit-wise AND of the 1's complement of the mask with the IP address.</p>
  <p class="zh">接着为了查找设备的网络，将IP地址与网络掩码按位与，而该设备在子网中的地址，可通过其IP地址按位与网络掩码的一补数找到。</p>

  <h3 id="heading_id_10" class="en">IPv6 addresses</h3>
  <h3 id="heading_id_10" class="zh">IPv6地址</h3>

  <p class="en">The internet has grown vastly beyond original expectations. The initially generous 32-bit addressing scheme is on the verge of running out. There are unpleasant workarounds such as NAT addressing, but eventually we will have to switch to a wider address space. IPv6 uses 128-bit addresses. Even bytes becomes cumbersome to express such addresses, so hexadecimal digits are used, grouped into 4 digits and separated by a colon ':'. A typical address might be 2002:c0e8:82e7:0:0:0:c0e8:82e7.</p>
  <p class="zh">因特网的迅速发展大大超出了原来的预期。最初富余的32位地址解决方案已经接近用完。虽然有一些例如NAT地址输入这样不是很完美的解决方法，但最终我们将不得不切换到更广阔的地址空间。IPv6使用128位地址，用单一的字节表示会显得很冗长，所以使用十六进制数字表示，每四个一组，由':'分隔。一个典型的例子如：2002:c0e8:82e7:0:0:0:c0e8:82e7。</p>

  <p class="en">These addresses are not easy to remember! DNS will become even more important. There are tricks to reducing some addresses, such as eliding zeroes and repeated digits. For example, "localhost" is 0:0:0:0:0:0:0:1, which can be shortened to ::1</p>
  <p class="zh">要记住这些地址并不容易！DNS将变得更加重要。有一些技巧用来缩短一些地址，如省略一些零和重复的数字。例如："localhost"地址是：0:0:0:0:0:0:0:1，可以缩短到::1。</p>

  <h2 id="heading_id_11" class="en">IP address type</h2>
  <h2 id="heading_id_11" class="zh">IP地址类型</h2>

  <h3 id="heading_id_12" class="en">The type IP</h3>
  <h2 id="heading_id_12" class="zh">IP类型</h2>

  <p class="en">The package "net" defines many types, functions and methods of use in Go network programming. The type <code>IP</code> is defined as an array of bytes</p>
  <p class="zh">"net"包定义了许多类型, 函数和方法用于Go网络编程。<code>IP</code>类型被定义为一个字节切片<del>数组</del>。</p>
  <pre>
    <code>
      type IP []byte
    </code>
  </pre>

  <p class="en">There are several functions to manipulate a variable of type <code>IP</code>, but you are likely to use only some of them in practice. For example, the function <code>ParseIP(String)</code> will take a dotted IPv4 address or a colon IPv6 address, while the <code>IP</code> method <code>String</code> will return a string. Note that you may not get back what you started with: the string form of 0:0:0:0:0:0:0:1 is ::1.</p>
  <p class="zh">有几个函数来处理一个<code>IP</code>类型的变量, 但实际上你很可能只用到其中的一些。例如, <code>ParseIP(String)</code>函数将获取句号分隔的IPv4或者冒号分隔的IPv6地址, 而<code>IP</code>的<code>String</code>方法将返回一个字符串。请注意，你可能无法取回你初始输入形式，如: 地址 0:0:0:0:0:0:0:1 的字符串形式是 ::1。</p>

  <p class="en">A program to illustrate this is</p>
  <p class="zh">下面用一个程序来说明</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* IP
 */
</span>
<span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
        <span class="sgc-3">"fmt"</span>
)

<span class="sgc-2">func</span> main() {
        <span class="sgc-2">if</span> len(os.<span class="sgc-4">Args</span>) != 2 {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Usage: %s ip-addr\n"</span>, os.<span class="sgc-4">Args</span>[0])
                os.<span class="sgc-4">Exit</span>(1)
        }
        name := os.<span class="sgc-4">Args</span>[1]

        addr := net.<span class="sgc-4">ParseIP</span>(name)
        <span class="sgc-2">if</span> addr == nil {
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Invalid address"</span>)
        } <span class="sgc-2">else</span> {
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"The address is "</span>, addr.<span class="sgc-4">String</span>())
        }
        os.<span class="sgc-4">Exit</span>(0)
}
</span></code></pre>

  <p class="en">If this is compiled to the executable <code>IP</code> then it can run for example as</p>
  <p class="zh">如果编译它为可执行文件<code>IP</code>，那么它可以运行如</p>
  <pre><code>
IP 127.0.0.1
    </code></pre>

  <p class="en">with response</p>
  <p class="zh">得到结果</p>
  <pre><code>
The address is 127.0.0.1
    </code></pre>

  <p class="en">or as</p>
  <p class="zh">或</p>
  <pre><code>
IP 0:0:0:0:0:0:0:1
    </code></pre>

  <p>得到结果</p>
  <pre><code>
The address is ::1
    </code></pre>

  <h3 id="heading_id_13" class="en">The type IPmask</h3>
  <h3 id="heading_id_13" class="zh">IP掩码</h3>

  <p class="en">In order to handle masking operations, there is the type</p>
  <p class="zh">为了处理掩码操作，有如下类型：</p>
  <pre>
    <code>
type IPMask []byte
    </code>
  </pre>

  <p class="en">There is a function to create a mask from a 4-byte IPv4 address</p>
  <p class="zh">下面这个函数用一个4字节的IPv4地址来创建一个掩码</p>
  <pre>
    <code>
func IPv4Mask(a, b, c, d byte) IPMask
    </code>
  </pre>

  <p class="en">Alternatively, there is a method of <code>IP</code> which returns the default mask</p>
  <p class="zh">另外, 这是一个<code>IP</code>的方法返回默认的掩码</p>
  <pre>
    <code>
func (ip IP) DefaultMask() IPMask
    </code>
  </pre>

  <p class="en">Note that the string form of a mask is a hex number such as ffff0000 for a mask of 255.255.0.0.</p>
  <p class="zh">需要注意的是一个掩码的字符串形式是一个十六进制数，如掩码255.255.0.0为ffff0000。</p>

  <p class="en">A mask can then be used by a method of an IP address to find the network for that IP address</p>
  <p class="zh">一个掩码可以用作一个IP地址的方法的参数，找到该IP地址的网络地址</p>
  <pre>
    <code>
func (ip IP) Mask(mask IPMask) IP
    </code>
  </pre>

  <p class="en">An example of the use of this is the following program:</p>
  <p class="zh">一个这种用法的例子如下面的程序：</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* Mask
 */
</span>
<span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"fmt"</span>
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
)

<span class="sgc-2">func</span> main() {
        <span class="sgc-2">if</span> len(os.<span class="sgc-4">Args</span>) != 2 {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Usage: %s dotted-ip-addr\n"</span>, os.<span class="sgc-4">Args</span>[0])
                os.<span class="sgc-4">Exit</span>(1)
        }
        dotAddr := os.<span class="sgc-4">Args</span>[1]

        addr := net.<span class="sgc-4">ParseIP</span>(dotAddr)
        <span class="sgc-2">if</span> addr == nil {
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Invalid address"</span>)
                os.<span class="sgc-4">Exit</span>(1)
        }
        mask := addr.<span class="sgc-4">DefaultMask</span>()
        network := addr.<span class="sgc-4">Mask</span>(mask)
        ones, bits := mask.<span class="sgc-4">Size</span>()
        fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Address is "</span>, addr.<span class="sgc-4">String</span>(),
                <span class="sgc-3">" Default mask length is "</span>, bits,
                <span class="sgc-3">"Leading ones count is "</span>, ones,
                <span class="sgc-3">"Mask is (hex) "</span>, mask.<span class="sgc-4">String</span>(),
                <span class="sgc-3">" Network is "</span>, network.<span class="sgc-4">String</span>())
        os.<span class="sgc-4">Exit</span>(0)
}
</span></code></pre>

  <p class="en">If this is compiled to <code>Mask</code> and run by</p>
  <p class="zh">编译并运行<code>Mask</code></p>
  <pre><code>
Mask 127.0.0.1
    </code></pre>

  <p class="en">it will return</p>
  <p class="zh">将返回</p>
  <pre><code>
Address is  127.0.0.1  Default mask length is  8  Network is  127.0.0.0
    </code></pre>

  <h3 id="heading_id_14" class="en">The type IPAddr</h3>
  <h3 id="heading_id_14" class="zh">IPAddr类型</h3>

  <p class="en">Many of the other functions and methods in the net package return a pointer to an <code>IPAddr</code>. This is simply a structure containing an <code>IP</code>.</p>
  <p class="zh">在net包的许多函数和方法会返回一个指向<code>IPAddr</code>的指针。这不过只是一个包含<code>IP</code>类型的结构体。</p>
  <pre>
    <code>
type IPAddr {
    IP IP
}
    </code>
  </pre>

  <p class="en">A primary use of this type is to perform DNS lookups on IP host names.</p>
  <p class="zh">这种类型的一种主要用途是通过IP主机名执行DNS查找。</p>
  <pre>
    <code>
func ResolveIPAddr(net, addr string) (*IPAddr, os.Error)
    </code>
  </pre>

  <p class="en">where <code>net</code> is one of "ip", "ip4" or "ip6". This is shown in the program</p>
  <p class="zh">其中<code>net</code>是"ip","ip4"或者"ip6"的其中一个. 下面的程序中将会展示。</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* ResolveIP
 */
</span>
<span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
        <span class="sgc-3">"fmt"</span>
)

<span class="sgc-2">func</span> main() {
        <span class="sgc-2">if</span> len(os.<span class="sgc-4">Args</span>) != 2 {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Usage: %s hostname\n"</span>, os.<span class="sgc-4">Args</span>[0])
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Usage: "</span>, os.<span class="sgc-4">Args</span>[0], <span class="sgc-3">"hostname"</span>)
                os.<span class="sgc-4">Exit</span>(1)
        }
        name := os.<span class="sgc-4">Args</span>[1]

        addr, err := net.<span class="sgc-4">ResolveIPAddr</span>(<span class="sgc-3">"ip"</span>, name)
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Resolution error"</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }
        fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Resolved address is "</span>, addr.<span class="sgc-4">String</span>())
        os.<span class="sgc-4">Exit</span>(0)
}
</span></code></pre>

  <p class="en">Running <code>ResolveIP www.google.com</code> returns</p>
  <p class="zh">运行<code>ResolveIP www.google.com</code>返回</p>
  <pre><code>
Resolved address is  66.102.11.104
    </code></pre>

  <h3 id="heading_id_15" class="en">Host lookup</h3>
  <h3 id="heading_id_15" class="zh">主机查询</h3>

  <p class="en">The function <code>ResolveIPAddr</code> will perform a DNS lookup on a hostname, and return a single IP address. However, hosts may have multiple IP addresses, usually from multiple network interface cards. They may also have multiple host names, acting as aliases.</p>
  <p class="zh"><code>ResolveIPAddr</code>函数将对某个主机名执行DNS查询，并返回单个IP地址。然而，通常主机如果有多个网卡，则可以有多个IP地址。它们也可能有多个主机名，作为别名。</p>
  <pre>
    <code>
func LookupHost(name string) (cname string, addrs []string, err os.Error)
    </code>
  </pre>

  <p class="en">One of these addresses will be labelled as the "canonical" host name. If you wish to find the canonical name, use <code>func LookupCNAME(name string) (cname string, err os.Error)</code></p>
  <p class="zh">这些地址的其中一个将会被标记为“正规的”主机名。如果你想找到正规主机名（canonical host name），使用<code>func LookupCNAME(name string) (cname string, err os.Error)</code></p>

  <p class="en">This is shown in the following program</p>
  <p class="zh">下面是一个演示程序</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* LookupHost
 */
</span>
<span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
        <span class="sgc-3">"fmt"</span>
)

<span class="sgc-2">func</span> main() {
        <span class="sgc-2">if</span> len(os.<span class="sgc-4">Args</span>) != 2 {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Usage: %s hostname\n"</span>, os.<span class="sgc-4">Args</span>[0])
                os.<span class="sgc-4">Exit</span>(1)
        }
        name := os.<span class="sgc-4">Args</span>[1]

        addrs, err := net.<span class="sgc-4">LookupHost</span>(name)
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Error: "</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(2)
        }

        <span class="sgc-2">for</span> <span class="sgc-6">_</span>, s := range addrs {
                fmt.<span class="sgc-4">Println</span>(s)
        }
        os.<span class="sgc-4">Exit</span>(0)
}
</span></code></pre>

  <p class="en">Note that this function returns strings, not <code>IPAddress</code> values.</p>
  <p class="zh">注意，这个函数返回字符串，而不是<code>IPAddress</code>。</p>

  <h2 id="heading_id_16" class="en">Services</h2>
  <h2 id="heading_id_16" class="zh">服务</h2>

  <p class="en">Services run on host machines. They are typically long lived and are designed to wait for requests and respond to them. There are many types of services, and there are many ways in which they can offer their services to clients. The internet world bases many of these services on two methods of communication, TCP and UDP, although there are other communication protocols such as SCTP waiting in the wings to take over. Many other types of service, such as peer-to-peer, remote procedure calls, communicating agents, and many others are built on top of TCP and UDP.</p>
  <p class="zh">服务运行在主机。它们通常长期存活，同时被设计成等待请求和响应请求。有许多类型的服务，有他们能够通过各种方法向客户提供服务。互联网的世界基于TCP和UDP这两种通信方法提供许多这些服务，虽然也有其他通信协议如SCTP​​伺机取代。许多其他类型的服务，例如点对点, 远程过程调用, 通信代理, 和许多其他建立在TCP和UDP之上的服务之上。</p>

  <h3 id="heading_id_17" class="en">Ports</h3>
  <h3 id="heading_id_17" class="zh">端口</h3>

  <p class="en">Services live on host machines. The IP address will locate the host. But on each computer may be many services, and a simple way is needed to distinguish between them. The method used by TCP, UDP, SCTP and others is to use a <em>port number</em>. This is an unsigned integer beween 1 and 65,535 and each service will associate itself with one or more of these port numbers.</p>
  <p class="zh">服务存活于主机内。IP地址可以定位主机。但在每台计算机上可能会提供多种服务，需要一个简单的方法对它们加以区分。TCP，UDP，SCTP或者其他协议使用<em>端口号</em>来加以区分。这里使用一个1到65,535的无符号整数，每个服务将这些端口号中的一个或多个相关联。</p>

  <p class="en">There are many "standard" ports. Telnet usually uses port 23 with the TCP protocol. DNS uses port 53, either with TCP or with UDP. FTP uses ports 21 and 20, one for commands, the other for data transfer. HTTP usually uses port 80, but it often uses ports 8000, 8080 and 8088, all with TCP. The X Window System often takes ports 6000-6007, both on TCP and UDP.</p>
  <p class="zh">有很多“标准”的端口。Telnet服务通常使用端口号23的TCP协议。DNS使用端口号53的TCP或UDP协议。FTP使用端口21和20，前者用于传输命令，后者进行数据传输。HTTP通常使用端口80，但也经常使用，端口8000，8080和8088，协议都为TCP。X Window系统往往占用端口6000-6007，无论TCP抑或UDP协议。</p>

  <p class="en">On a Unix system, the commonly used ports are listed in the file <code>/etc/services</code>. Go has a function to interrogate this file</p>
  <p class="zh">在Unix系统中, <code>/etc/services</code>文件列出了常用的端口。Go语言有一个函数可以获取该文件。</p>
  <pre>
    <code>
func LookupPort(network, service string) (port int, err os.Error)
    </code>
  </pre>

  <p class="en">The network argument is a string such as "tcp" or "udp", while the service is a string such as "telnet" or "domain" (for DNS).</p>
  <p class="zh">network是一个字符串例如"tcp"或"udp", service也是一个字符串，如"telnet"或"domain"(DNS)。</p>

  <p class="en">A program using this is</p>
  <p class="zh">示例程序如下</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* LookupPort
 */
</span>
<span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
        <span class="sgc-3">"fmt"</span>
)

<span class="sgc-2">func</span> main() {
        <span class="sgc-2">if</span> len(os.<span class="sgc-4">Args</span>) != 3 {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>,
                        <span class="sgc-3">"Usage: %s network-type service\n"</span>,
                        os.<span class="sgc-4">Args</span>[0])
                os.<span class="sgc-4">Exit</span>(1)
        }
        networkType := os.<span class="sgc-4">Args</span>[1]
        service := os.<span class="sgc-4">Args</span>[2]

        port, err := net.<span class="sgc-4">LookupPort</span>(networkType, service)
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Error: "</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(2)
        }

        fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Service port "</span>, port)
        os.<span class="sgc-4">Exit</span>(0)
}
</span></code></pre>

  <p class="en">For example, running <code>LookupPort tcp telnet</code> prints <code>Service port: 23</code></p>
  <p class="zh">举个例子, 运行<code>LookupPort tcp telnet</code> 打印 <code>Service port: 23</code></p>

  <h3 id="heading_id_18" class="en">The type TCPAddr</h3>
  <h3 id="heading_id_18" class="zh">TCPAddr类型</h3>

  <p class="en">The type <code>TCPAddr</code> is a structure containing an <code>IP</code> and a <code>port</code>:</p>
  <p class="zh"><code>TCPAddr</code>类型包含一个<code>IP</code>和一个<code>port</code>的结构:</p>
  <pre>
    <code>
type TCPAddr struct {
    IP   IP
    Port int
}
    </code>
  </pre>

  <p class="en">The function to create a <code>TCPAddr</code> is <code>ResolveTCPAddr</code></p>
  <p class="zh">函数<code>ResolveTCPAddr</code>用来创建一个<code>TCPAddr</code></p>
  <pre>
    <code>
func ResolveTCPAddr(net, addr string) (*TCPAddr, os.Error)
    </code>
  </pre>

  <p class="en">where <code>net</code> is one of "tcp", "tcp4" or "tcp6" and the <code>addr</code> is a string composed of a host name or IP address, followed by the port number after a ":", such as "www.google.com:80" or '127.0.0.1:22". if the address is an IPv6 address, which already has colons in it, then the host part must be enclosed in square brackets, such as "[::1]:23". Another special case is often used for servers, where the host address is zero, so that the TCP address is really just the port name, as in ":80" for an HTTP server.</p>
  <p class="zh"><code>net</code>是"tcp", "tcp4"或"tcp6"其中之一，<code>addr</code>是一个字符串，由主机名或IP地址，以及":"后跟随着端口号组成，例如： "www.google.com:80" 或 '127.0.0.1:22"。如果地址是一个IPv6地址，由于已经有冒号，主机部分，必须放在方括号内, 例如："[::1]:23". 另一种特殊情况经常用于服务器, 主机地址为0时, 那么TCP地址实际上就仅是是端口名称, 例如：":80" 用来表示HTTP服务器。</p>

  <h2 id="heading_id_19" class="en">TCP Sockets</h2>
  <h2 id="heading_id_19" class="zh">TCP套接字</h2>

  <p class="en">When you know how to reach a service via its network and port IDs, what then? If you are a client you need an API that will allow you to connect to a service and then to send messages to that service and read replies back from the service.</p>
  <p class="zh">当你知道如何通过网络和端口ID查找一个服务时，然后呢？如果你是一个客户端，你需要一个API，让你连接到服务，然后将消息发送到该服务，并从服务读取回复。</p>

  <p class="en">If you are a server, you need to be able to bind to a port and listen at it. When a message comes in you need to be able to read it and write back to the client.</p>
  <p class="zh">如果你是一个服务器，你需要能够绑定到一个端口，并监听它。当有消息到来，你需要能够读取它并回复客户端。</p>

  <p class="en">The <code>net.TCPConn</code> is the Go type which allows full duplex communication between the client and the server. Two major methods of interest are</p>
  <p class="zh"><code>net.TCPConn</code>是允许在客户端和服务器之间的全双工通信的Go类型。两种主要方法是</p>
  <pre><code>
func (c *TCPConn) Write(b []byte) (n int, err os.Error)
func (c *TCPConn) Read(b []byte) (n int, err os.Error)   
    </code></pre>

  <p class="en">A <code>TCPConn</code> is used by both a client and a server to read and write messages.</p>
  <p class="zh"><code>TCPConn</code>被客户端和服务器用来读写消息。/p>

  <h3 id="heading_id_20" class="en">TCP client</h3>
  <h3 id="heading_id_20" class="zh">TCP客户端</h3>

  <p class="en">Once a client has established a TCP address for a service, it "dials" the service. If succesful, the dial returns a <code>TCPConn</code> for communication. The client and the server exchange messages on this. Typically a client writes a request to the server using the <code>TCPConn</code>, and reads a response from the <code>TCPConn</code>. This continues until either (or both) sides close the connection. A TCP connection is established by the client using the function</p>
  <p class="zh">一旦客户端已经建立TCP服务, 就可以和对方设备"通话"了. 如果成功，该调用返回一个用于通信的<code>TCPConn</code>。客户端和服务器通过它交换消息。通常情况下，客户端使用<code>TCPConn</code>写入请求到服务器, 并从<code>TCPConn</code>的读取响应。持续如此，直到任一（或两者）的两侧关闭连接。客户端使用该函数建立一个TCP连接。</p>
  <pre><code>
func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err os.Error)
    </code></pre>

  <p class="en">where <code>laddr</code> is the local address which is usually set to <code>nil</code> and <code>raddr</code> is the remote address of the service, and the <code>net</code> string is one of "tcp4", "tcp6" or "tcp" depending on whether you want a TCPv4 connection, a TCPv6 connection or don't care.</p>
  <p class="zh">其中<code>laddr</code>是本地地址，通常设置为<code>nil</code>。<code>raddr</code>是一个服务的远程地址, <code>net</code>是一个字符串，根据你是否希望是一个TCPv4连接，TCPv6连接来设置为"tcp4", "tcp6"或"tcp"中的一个，当然你也可以不关心链接形式。</p>

  <p class="en">A simple example can be provided by a client to a web (HTTP) server. We will deal in substantially more detail with HTTP clients and servers in a later chapter, but for now we will keep it simple.</p>
  <p class="zh">一个简单的例子，展示一个客户端连接到一个网页(HTTP)服务器。在后面的章节，我们将处理大量的HTTP客户端和服务器细节，现在我们先从简单的看看。</p>

  <p class="en">One of the possible messages that a client can send is the "HEAD" message. This queries a server for information about the server and a document on that server. The server returns information, but does not return the document itself. The request sent to query an HTTP server could be</p>
  <p class="zh">客户端可能发送的消息之一就是“HEAD”消息。这用来查询服务器的信息和文档信息。 服务器返回的信息，不返回文档本身。发送到服务器的请求可能是</p>
  <pre><code>
"HEAD / HTTP/1.0\r\n\r\n"
    </code></pre>

  <p class="en">which asks for information about the root document and the server. A typical response might be</p>
  <p class="zh">这是在请求关于服务器以及根文档的信息。 一个典型的响应可能是</p>
  <pre><code>
HTTP/1.0 200 OK
ETag: "-9985996"
Last-Modified: Thu, 25 Mar 2010 17:51:10 GMT
Content-Length: 18074
Connection: close
Date: Sat, 28 Aug 2010 00:43:48 GMT
Server: lighttpd/1.4.23
    </code></pre>

  <p class="en">We first give the program (GetHeadInfo.go) to establish the connection for a TCP address, send the request string, read and print the response. Once compiled it can be invoked by e.g.</p>
  <p class="zh">我们首先通过(GetHeadInfo.go)程序来建立TCP连接，发送请求字符串，读取并打印响应。编译后就可以调用，例如：</p>
  <pre><code>
GetHeadInfo www.google.com:80
    </code></pre>

  <p class="en">The program is</p>
  <p class="en">程序</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* GetHeadInfo
 */
</span><span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
        <span class="sgc-3">"fmt"</span>
        <span class="sgc-3">"io/ioutil"</span>
)

<span class="sgc-2">func</span> main() {
        <span class="sgc-2">if</span> len(os.<span class="sgc-4">Args</span>) != 2 {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Usage: %s host:port "</span>, os.<span class="sgc-4">Args</span>[0])
                os.<span class="sgc-4">Exit</span>(1)
        }
        service := os.<span class="sgc-4">Args</span>[1]

        tcpAddr, err := net.<span class="sgc-4">ResolveTCPAddr</span>(<span class="sgc-3">"tcp4"</span>, service)
        checkError(err)

        conn, err := net.<span class="sgc-4">DialTCP</span>(<span class="sgc-3">"tcp"</span>, nil, tcpAddr)
        checkError(err)

        <span class="sgc-6">_</span>, err = conn.<span class="sgc-4">Write</span>([]<span class="sgc-7">byte</span>(<span class="sgc-3">"HEAD / HTTP/1.0\r\n\r\n"</span>))
        checkError(err)

        <span class="sgc-1">//result, err := readFully(conn)
</span> result, err := ioutil.<span class="sgc-4">ReadAll</span>(conn)
        checkError(err)

        fmt.<span class="sgc-4">Println</span>(string(result))

        os.<span class="sgc-4">Exit</span>(0)
}

<span class="sgc-2">func</span> checkError(err error) {
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Fatal error: %s"</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }
}
</span></code></pre>

  <p class="en">The first point to note is the almost excessive amount of error checking that is going on. This is normal for networking programs: the opportunities for failure are substantially greater than for standalone programs. Hardware may fail on the client, the server, or on any of the routers and switches in the middle; communication may be blocked by a firewall; timeouts may occur due to network load; the server may crash while the client is talking to it. The following checks are performed:</p>
  <p class="zh">第一个要注意的点是近乎多余的错误检查。因为正常情况下，网络程序失败的机会大大超过单机的程序。在客户端，服务器端或任何路由和中间交换机上，硬件可能失败；通信可能会被防火墙阻塞;因网络负载可能会出现超时;当客户端联系服务器，服务器可能会崩溃，下列检查是必须的：</p>
  <ol class="en">
    <li>There may be syntax errors in the address specified</li>

    <li>The attempt to connect to the remote service may fail. For example, the service requested might not be running, or there may be no such host connected to the network</li>

    <li>Although a connection has been established, writes to the service might fail if the connection has died suddenly, or the network times out</li>

    <li>Similarly, the reads might fail</li>
  </ol>
  <ol class="zh">
    <li>指定的地址中可能存在语法错误</li>

    <li>尝试连接到远程服务可能会失败。例如, 所请求的服务可能没有运行, 或者有可能是主机没有连接到网络</li>

    <li>虽然连接已经建立，如果连接突然丢失也可能导致写失败，或网络超时</li>

    <li>同样，读操作也可能会失败</li>
  </ol>

  <p class="en">Reading from the server requires a comment. In this case, we read essentially a single response from the server. This will be terminated by end-of-file on the connection. However, it may consist of several TCP packets, so we need to keep reading till the end of file. The <code>io/ioutil</code> function <code>ReadAll</code> will look after these issues and return the complete response. (Thanks to Roger Peppe on the golang-nuts mailing list.).</p>
  <p class="zh">值得一提的是,如何从服务端读取数据。在这种情况下，读取的基本上是来自单一的服务器的响应。并且会由连接中的EOF终止。但是，它可能包括多个TCP数据包，所以我们需要不断地读，直到文件的末尾。在<code>io/ioutil</code>下的<code>ReadAll</code>函数考虑这些问题，并返回完整响应。(感谢golang-nuts邮件列表上的Roger Peppe。)。</p>

  <p class="en">There are some language issues involved. First, most of the functions return a dual value, with possible error as second value. If no error occurs, then this will be <code>nil</code>. In C, the same behaviour is gained by special values such as <code>NULL</code>, or -1, or zero being returned - if that is possible. In Java, the same error checking is managed by throwing and catching exceptions, which can make the code look very messy.</p>
  <p class="zh">有一些涉及语言的问题，首先, 大多数函数返回两个值, 第二个值是可能出现的错误。如果没有错误发生, 那么它的值为<code>nil</code>。在C中, 如果需要的话，同样的行为通过定义特殊值例如<code>NULL</code>, 或 -1, 或0来返回。在Java中, 同样的错误检查通过抛出和捕获异常来管理，它会使代码看起来很凌乱。</p>

  <p class="en">In earlier versions of this program, I returned the result in the array <code>buf</code>, which is of type <code>[512]byte</code>. Attempts to coerce this to a string failed - only byte arrays of type <code>[]byte</code> can be coerced. This is a bit of a nuisance.</p>
  <p class="zh">在这个程序的早期版本, 我在返回结果中返回<code>buf</code>数组, 它的类型是<code>[512]byte</code>。我试图强制转换类型为一个字符串但失败了- 只有字节切片<del>数组</del>类型<code>[]byte</code>可以强制转换。这确实有点困扰。</p>

  <h3 id="heading_id_21" class="en">A Daytime server</h3>
  <h3 id="heading_id_21" class="zh">一个时间(Daytime)服务器</h3>

  <p class="en">About the simplest service that we can build is the daytime service. This is a standard Internet service, defined by RFC 867, with a default port of 13, on both TCP and UDP. Unfortunately, with the (justified) increase in paranoia over security, hardly any sites run a daytime server any more. Never mind, we can build our own. (For those interested, if you install <code>inetd</code> on your system, you usually get a daytime server thrown in.)</p>
  <p class="zh">最简单的服务，我们可以建立是时间(Daytime)服务。这是一个标准的互联网服务, 由RFC 867定义, 默认的端口13, 协议是TCP和UDP。很遗憾, 对安全的偏执，几乎没有任何站点运行着时间(Daytime)服务器。不过没关系，我们可以建立我们自己的。 (对于那些有兴趣, 你可以在你的系统安装<code>inetd</code>, 你通常可以得到一个时间(Daytime)服务器。)</p>

  <p class="en">A server registers itself on a port, and listens on that port. Then it blocks on an "accept" operation, waiting for clients to connect. When a client connects, the accept call returns, with a connection object. The daytime service is very simple and just writes the current time to the client, closes the connection, and resumes waiting for the next client.</p>
  <p class="zh">在一个服务器上注册并监听一个端口。然后它阻塞在一个"accept"操作，并等待客户端连接。当一个客户端连接, accept调用返回一个连接(connection)对象。时间(Daytime)服务非常简单，只是将当前时间写入到客户端, 关闭该连接，并继续等待下一个客户端。</p>

  <p class="en">The relevant calls are</p>
  <p class="zh">有关调用</p>
  <pre><code>
func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err os.Error)
func (l *TCPListener) Accept() (c Conn, err os.Error)
    </code></pre>

  <p class="en">The argument <code>net</code> can be set to one of the strings "tcp", "tcp4" or "tcp6". The IP address should be set to zero if you want to listen on all network interfaces, or to the IP address of a single network interface if you only want to listen on that interface. If the port is set to zero, then the O/S will choose a port for you. Otherwise you can choose your own. Note that on a Unix system, you cannot listen on a port below 1024 unless you are the system supervisor, root, and ports below 128 are standardised by the IETF. The example program chooses port 1200 for no particular reason. The TCP address is given as ":1200" - all interfaces, port 1200.</p>
  <p class="zh"><code>net</code>参数可以设置为字符串"tcp", "tcp4"或者"tcp6"中的一个。如果你想监听所有网络接口，IP地址应设置为0，或如果你只是想监听一个简单网络接口，IP地址可以设置为该网络的地址。如果端口设置为0，O/S会为你选择一个端口。否则，你可以选择你自己的。需要注意的是，在Unix系统上，除非你是监控系统，否则不能监听低于1024的端口，小于128的端口是由IETF标准化。该示例程序选择端口1200没有特别的原因。TCP地址如下":1200" - 所有网络接口, 端口1200。</p>

  <p class="en">The program is</p>
  <p class="zh">程序</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* DaytimeServer
 */
</span><span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"fmt"</span>
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
        <span class="sgc-3">"time"</span>
)

<span class="sgc-2">func</span> main() {

        service := <span class="sgc-3">":1200"</span>
        tcpAddr, err := net.<span class="sgc-4">ResolveTCPAddr</span>(<span class="sgc-3">"tcp4"</span>, service)
        checkError(err)

        listener, err := net.<span class="sgc-4">ListenTCP</span>(<span class="sgc-3">"tcp"</span>, tcpAddr)
        checkError(err)

        <span class="sgc-2">for</span> {
                conn, err := listener.<span class="sgc-4">Accept</span>()
                <span class="sgc-2">if</span> err != nil {
                        <span class="sgc-2">continue</span>
                }

                daytime := time.<span class="sgc-4">Now</span>().<span class="sgc-4">String</span>()
                conn.<span class="sgc-4">Write</span>([]<span class="sgc-7">byte</span>(daytime)) <span class="sgc-1">// don't care about return value
</span>         conn.<span class="sgc-4">Close</span>()                <span class="sgc-1">// we're finished with this client
</span> }
}

<span class="sgc-2">func</span> checkError(err error) {
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Fatal error: %s"</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }
}
</span></code></pre>

  <p class="en">If you run this server, it will just wait there, not doing much. When a client connects to it, it will respond by sending the daytime string to it and then return to waiting for the next client.</p>
  <p class="zh">如果你运行该服务器, 它会在那里等待， 没有做任何事。当一个客户端连接到该服务器, 它会响应发送时间(Daytime)字符串，然后继续等待下一个客户端。</p>

  <p class="en">Note the changed error handling in the server as compared to a client. The server should run forever, so that if any error occurs with a client, the server just ignores that client and carries on. A client could otherwise try to mess up the connection with the server, and bring it down!</p>
  <p class="zh">相比客户端服务器更要注意对错误的处理。服务器应该永远运行，所以，如果出现任何错误与客户端，服务器只是忽略客户端继续运行。否则，客户端可以尝试搞砸了与服务器的连接，并导致服务器宕机。</p>

  <p class="en">We haven't built a client. That is easy, just changing the previous client to omit the initial write. Alternatively, just open up a <code>telnet</code> connection to that host:</p>
  <p class="zh">我们还没有建立一个客户端。这很简单，只需要修改以前的客户端例子并去掉的初始写入。或者, 只需打开一个<code>telnet</code>连接到该主机：</p>
  <pre><code>
telnet localhost 1200
    </code></pre>

  <p class="en">This will produce output such as</p>
  <p class="zh">输出如下：</p>
  <pre><code>
$telnet localhost 1200
Trying ::1...
Connected to localhost.
Escape character is '^]'.
Sun Aug 29 17:25:19 EST 2010Connection closed by foreign host.
    </code></pre>

  <p class="en">where "Sun Aug 29 17:25:19 EST 2010" is the output from the server.</p>
  <p class="zh">服务器输出："Sun Aug 29 17:25:19 EST 2010"。</p>

  <h3 id="heading_id_22" class="en">Multi-threaded server</h3>
  <h3 id="heading_id_22" class="zh">多线程服务器</h3>

  <p class="en">"echo" is another simple IETF service. This just reads what the client types, and sends it back:</p>
  <p class="zh">"echo"是另一种简单的IETF服务。只是读取客户端数据，并将其发送回去:</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* SimpleEchoServer
 */
</span><span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
        <span class="sgc-3">"fmt"</span>
)

<span class="sgc-2">func</span> main() {

        service := <span class="sgc-3">":1201"</span>
        tcpAddr, err := net.<span class="sgc-4">ResolveTCPAddr</span>(<span class="sgc-3">"tcp4"</span>, service)
        checkError(err)

        listener, err := net.<span class="sgc-4">ListenTCP</span>(<span class="sgc-3">"tcp"</span>, tcpAddr)
        checkError(err)

        <span class="sgc-2">for</span> {
                conn, err := listener.<span class="sgc-4">Accept</span>()
                <span class="sgc-2">if</span> err != nil {
                        <span class="sgc-2">continue</span>
                }
                handleClient(conn)
                conn.<span class="sgc-4">Close</span>() <span class="sgc-1">// we're finished
</span> }
}

<span class="sgc-2">func</span> handleClient(conn net.<span class="sgc-4">Conn</span>) {
        <span class="sgc-2">var</span> buf [512]<span class="sgc-7">byte</span>
        <span class="sgc-2">for</span> {
                n, err := conn.<span class="sgc-4">Read</span>(buf[0:])
                <span class="sgc-2">if</span> err != nil {
                        <span class="sgc-2">return</span>
                }
                fmt.<span class="sgc-4">Println</span>(string(buf[0:]))
                <span class="sgc-6">_</span>, err2 := conn.<span class="sgc-4">Write</span>(buf[0:n])
                <span class="sgc-2">if</span> err2 != nil {
                        <span class="sgc-2">return</span>
                }
        }
}

<span class="sgc-2">func</span> checkError(err error) {
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Fatal error: %s"</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }
}
</span></code></pre>

  <p class="en">While it works, there is a significant issue with this server: it is single-threaded. While a client has a connection open to it, no other cllient can connect. Other clients are blocked, and will probably time out. Fortunately this is easly fixed by making the client handler a go-routine. We have also moved the connection close into the handler, as it now belongs there</p>
  <p class="zh">工作时，此服务器有一个明显的问题: 它是单线程的。当有一个客户端连接到它，就没有其他的客户端可以连接上。其他客户端将被阻塞，可能会超时。幸好客户端很容易使用go-routine扩展。我们仅仅需要把连接关闭移到处理程序结束后，示例代码如下：</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* ThreadedEchoServer
 */
</span><span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
        <span class="sgc-3">"fmt"</span>
)

<span class="sgc-2">func</span> main() {

        service := <span class="sgc-3">":1201"</span>
        tcpAddr, err := net.<span class="sgc-4">ResolveTCPAddr</span>(<span class="sgc-3">"ip4"</span>, service)
        checkError(err)

        listener, err := net.<span class="sgc-4">ListenTCP</span>(<span class="sgc-3">"tcp"</span>, tcpAddr)
        checkError(err)

        <span class="sgc-2">for</span> {
                conn, err := listener.<span class="sgc-4">Accept</span>()
                <span class="sgc-2">if</span> err != nil {
                        <span class="sgc-2">continue</span>
                }
                <span class="sgc-1">// run as a goroutine
</span>         go handleClient(conn)
        }
}

<span class="sgc-2">func</span> handleClient(conn net.<span class="sgc-4">Conn</span>) {
        <span class="sgc-1">// close connection on exit
</span> defer conn.<span class="sgc-4">Close</span>()

        <span class="sgc-2">var</span> buf [512]<span class="sgc-7">byte</span>
        <span class="sgc-2">for</span> {
                <span class="sgc-1">// read upto 512 bytes
</span>         n, err := conn.<span class="sgc-4">Read</span>(buf[0:])
                <span class="sgc-2">if</span> err != nil {
                        <span class="sgc-2">return</span>
                }

                <span class="sgc-1">// write the n bytes read
</span>         <span class="sgc-6">_</span>, err2 := conn.<span class="sgc-4">Write</span>(buf[0:n])
                <span class="sgc-2">if</span> err2 != nil {
                        <span class="sgc-2">return</span>
                }
        }
}

<span class="sgc-2">func</span> checkError(err error) {
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Fatal error: %s"</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }
}
</span></code></pre>

  <h2 id="heading_id_23" class="en">Controlling TCP connections</h2>
  <h2 id="heading_id_23" class="zh">控制TCP连接</h2>

  <h3 id="heading_id_24" class="en">Timeout</h3>
  <h3 id="heading_id_24" class="zh">超时</h3>

  <p class="en">The server may wish to timeout a client if it does not respond quickly enough i.e. does not write a request to the server in time. This should be a long period (several minutes), because the user may be taking their time. Conversely, the client may want to timeout the server (after a much shorter time). Both do this by</p>
  <p class="zh">服务端会断开那些超时的客户端，如果他们响应不够快，比如没有及时往服务端写一个请求。这应该是长时间(几分钟)的，因为用户可能需要一定的时间。相反, 客户端可能更希望能设置与服务器连接的超时(一个更短的时间)。这两种都可以通过调用</p>
  <pre><code>
func (c *TCPConn) SetTimeout(nsec int64) os.Error
</code></pre>

  <p class="en">before any reads or writes on the socket.</p>
  <p class="zh">在套接字任何读写操作发生前。</p>

  <h3 id="heading_id_25" class="en">Staying alive</h3>
  <h3 id="heading_id_25" class="zh">存活状态</h3>

  <p class="en">A client may wish to stay connected to a server even if it has nothing to send. It can use</p>
  <p class="zh">即使没有任何通信，一个客户端可能希望保持连接到服务器的状态。可以使用</p>
  <pre><code>
func (c *TCPConn) SetKeepAlive(keepalive bool) os.Error
  </code></pre>

  <p class="en">There are several other connection control methods, documented in the "net" package.</p>
  <p class="zh">还有几个其他的连接控制方法, 可以查看"net"包。</p>

  <h2 id="heading_id_26" class="en">UDP Datagrams</h2>
  <h2 id="heading_id_26" class="zh">UDP数据报</h2>

  <p class="en">In a connectionless protocol each message contains information about its origin and destination. There is no "session" established using a long-lived socket. UDP clients and servers make use of datagrams, which are individual messages containing source and destination information. There is no state maintained by these messages, unless the client or server does so. The messages are not guaranteed to arrive, or may arrive out of order.</p>
  <p class="zh">在一个无连接的协议中，每个消息都包含了关于它的来源和目的地的信息。没有"session"建立在使用长连接的套接字上。UDP客户端和服务器使用的数据包，单独包含来源和目的地的信息。除非客户端或服务器这样做，否则消息的状态不会保持。这些消息不能保证一定到达，也可能保证按顺序到达。</p>

  <p class="en">The most common situation for a client is to send a message and hope that a reply arrives. The most common situation for a server would be to receive a message and then send one or more replies back to that client. In a peer-to-peer situation, though, the server may just forward messages to other peers.</p>
  <p class="zh">客户端最常见的情况是发送消息，并希望响应正常到达。服务器最常见的情况为收到一条消息，然后发送一个或多个回复给客户端。而在点对点的情况下， 服务器可能仅仅是把消息转发到其他点。</p>

  <p class="en">The major difference between TCP and UDP handling for Go is how to deal with packets arriving from possibly multiple clients, without the cushion of a TCP session to manage things. The major calls needed are</p>
  <p class="zh">Go下处理TCP和UDP之间的主要区别是如何处理多个客户端可能同时有数据包到达，没有一个管理TCP会话的缓冲。主要需要调用的是</p>
  <pre><code>
func ResolveUDPAddr(net, addr string) (*UDPAddr, os.Error)
func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err os.Error)
func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err os.Error)
func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err os.Error
func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err os.Error)
    </code></pre>

  <p class="en">The client for a UDP time service doesn't need to make many changes, just changing <code>...TCP...</code> calls to <code>...UDP...</code> calls:</p>
  <p class="zh">UDP时间服务的客户端并不需要做很多的变化，仅仅改变<code>...TCP...</code>调用为<code>...UDP...</code>调用:</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* UDPDaytimeClient
 */
</span><span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
        <span class="sgc-3">"fmt"</span>
)

<span class="sgc-2">func</span> main() {
        <span class="sgc-2">if</span> len(os.<span class="sgc-4">Args</span>) != 2 {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Usage: %s host:port"</span>, os.<span class="sgc-4">Args</span>[0])
                os.<span class="sgc-4">Exit</span>(1)
        }
        service := os.<span class="sgc-4">Args</span>[1]

        udpAddr, err := net.<span class="sgc-4">ResolveUDPAddr</span>(<span class="sgc-3">"up4"</span>, service)
        checkError(err)

        conn, err := net.<span class="sgc-4">DialUDP</span>(<span class="sgc-3">"udp"</span>, nil, udpAddr)
        checkError(err)

        <span class="sgc-6">_</span>, err = conn.<span class="sgc-4">Write</span>([]<span class="sgc-7">byte</span>(<span class="sgc-3">"anything"</span>))
        checkError(err)

        <span class="sgc-2">var</span> buf [512]<span class="sgc-7">byte</span>
        n, err := conn.<span class="sgc-4">Read</span>(buf[0:])
        checkError(err)

        fmt.<span class="sgc-4">Println</span>(string(buf[0:n]))

        os.<span class="sgc-4">Exit</span>(0)
}

<span class="sgc-2">func</span> checkError(err error) {
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Fatal error "</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }
}
</span></code></pre>

  <p class="en">while the server has to make a few more:</p>
  <p class="zh">服务器也有很少的改动:</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* UDPDaytimeServer
 */
</span><span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"fmt"</span>
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
        <span class="sgc-3">"time"</span>
)

<span class="sgc-2">func</span> main() {

        service := <span class="sgc-3">":1200"</span>
        udpAddr, err := net.<span class="sgc-4">ResolveUDPAddr</span>(<span class="sgc-3">"up4"</span>, service)
        checkError(err)

        conn, err := net.<span class="sgc-4">ListenUDP</span>(<span class="sgc-3">"udp"</span>, udpAddr)
        checkError(err)

        <span class="sgc-2">for</span> {
                handleClient(conn)
        }
}

<span class="sgc-2">func</span> handleClient(conn *net.<span class="sgc-4">UDPConn</span>) {

        <span class="sgc-2">var</span> buf [512]<span class="sgc-7">byte</span>

        <span class="sgc-6">_</span>, addr, err := conn.<span class="sgc-4">ReadFromUDP</span>(buf[0:])
        <span class="sgc-2">if</span> err != nil {
                <span class="sgc-2">return</span>
        }

        daytime := time.<span class="sgc-4">Now</span>().<span class="sgc-4">String</span>()

        conn.<span class="sgc-4">WriteToUDP</span>([]<span class="sgc-7">byte</span>(daytime), addr)
}

<span class="sgc-2">func</span> checkError(err error) {
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Fatal error "</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }
}
</span></code></pre>

  <h2 id="heading_id_27" class="en">Server listening on multiple sockets</h2>
  <h2 id="heading_id_27" class="zh">服务器侦听多个套接字</h2>

  <p class="en">A server may be attempting to listen to multiple clients not just on one port, but on many. In this case it has to use some sort of polling mechanism between the ports.</p>
  <p class="zh">一个服务器可能不止在一个端口监听多个客户端，或是更多端口，在这种情况下，它在端口之间使用某种轮询机制。</p>

  <p class="en">In C, the select() call lets the kernel do this work. The call takes a number of file descriptors. The process is suspended. When I/O is ready on one of these, a wakeup is done, and the process can continue. This is cheaper than busy polling. In Go, accomplish the same by using a different goroutine for each port. A thread will become runnable when the lower-level select() discovers that I/O is ready for this thread.</p>
  <p class="zh">在C中, 调用的select()可以让内核完成这项工作。 这个调用需要传入一些文件描述符。然后该进程被暂停。当其中一个文件的I/O准备好时，进程就会被唤醒，并且该进程可以继续。这样花销比不停轮询更廉价. 在GO中,通过为每个端口使用一个不同的goroutine完成相同的功能。线程可以在更底层的select()等待I/O可用时继续运行。</p>

  <h2 id="heading_id_28" class="en">The types Conn, PacketConn and Listener</h2>
  <h2 id="heading_id_28" class="zh">Conn，PacketConn和Listener类型</h2>

  <p class="en">So far we have differentiated between the API for TCP and the API for UDP, using for example <code>DialTCP</code> and <code>DialUDP</code> returning a <code>TCPConn</code> and <code>UDPConn</code> respectively. The type <code>Conn</code> is an interface and both <code>TCPConn</code> and <code>UDPConn</code> implement this interface. To a large extent you can deal with this interface rather than the two types.</p>
  <p class="zh">迄今为止我们已经区分TCP和UDP API的不同，通过例子<code>DialTCP</code>和<code>DialUDP</code>分别返回一个<code>TCPConn</code>和 <code>UDPConn</code>。<code>Conn</code>类型是一个接口，<code>TCPConn</code>和<code>UDPConn</code>实现了该接口。在很大程度上，你可以通过该接口处理而不是用这两种类型。</p>

  <p class="en">Instead of separate dial functions for TCP and UDP, you can use a single function</p>
  <p class="zh">你可以使用一个简单的函数，而不是单独使用TCP和UDP的dial函数。</p>
  <pre>
    <code>
func Dial(net, laddr, raddr string) (c Conn, err os.Error)
    </code>
  </pre>

  <p class="en">The <code>net</code> can be any of "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only), "udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4" (IPv4-only) and "ip6" (IPv6-only). It will return an appropriate implementation of the <code>Conn</code> interface. Note that this function takes a string rather than address as <code>raddr</code> argument, so that programs using this can avoid working out the address type first.</p>
  <p class="zh"><code>net</code>可以是"tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only), "udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4" (IPv4-only)和"ip6" (IPv6-only)任何一种。它将返回一个实现了<code>Conn</code>接口的类型。注意此函数接受一个字符串类型而不是地址类型的值作为<code>raddr</code>参数，因此使用这个函数的程序可以避免先解析出对应的地址。</p>

  <p class="en">Using this function makes minor changes to programs. For example, the earlier program to get HEAD information from a Web page can be re-written as</p>
  <p class="zh">使用该函数需要对程序轻微的调整。例如, 前面的程序从一个Web页面获取HEAD信息可以被重新写为</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* IPGetHeadInfo
 */
</span><span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"bytes"</span>
        <span class="sgc-3">"fmt"</span>
        <span class="sgc-3">"io"</span>
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
)

<span class="sgc-2">func</span> main() {
        <span class="sgc-2">if</span> len(os.<span class="sgc-4">Args</span>) != 2 {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Usage: %s host:port"</span>, os.<span class="sgc-4">Args</span>[0])
                os.<span class="sgc-4">Exit</span>(1)
        }
        service := os.<span class="sgc-4">Args</span>[1]

        conn, err := net.<span class="sgc-4">Dial</span>(<span class="sgc-3">"tcp"</span>, service)
        checkError(err)

        <span class="sgc-6">_</span>, err = conn.<span class="sgc-4">Write</span>([]<span class="sgc-7">byte</span>(<span class="sgc-3">"HEAD / HTTP/1.0\r\n\r\n"</span>))
        checkError(err)

        result, err := readFully(conn)
        checkError(err)

        fmt.<span class="sgc-4">Println</span>(string(result))

        os.<span class="sgc-4">Exit</span>(0)
}

<span class="sgc-2">func</span> checkError(err error) {
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Fatal error: %s"</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }
}

<span class="sgc-2">func</span> readFully(conn net.<span class="sgc-4">Conn</span>) ([]<span class="sgc-7">byte</span>, error) {
        defer conn.<span class="sgc-4">Close</span>()

        result := bytes.<span class="sgc-4">NewBuffer</span>(nil)
        <span class="sgc-2">var</span> buf [512]<span class="sgc-7">byte</span>
        <span class="sgc-2">for</span> {
                n, err := conn.<span class="sgc-4">Read</span>(buf[0:])
                result.<span class="sgc-4">Write</span>(buf[0:n])
                <span class="sgc-2">if</span> err != nil {
                        <span class="sgc-2">if</span> err == io.<span class="sgc-4">EOF</span> {
                                <span class="sgc-2">break</span>
                        }
                        <span class="sgc-2">return</span> nil, err
                }
        }
        <span class="sgc-2">return</span> result.<span class="sgc-4">Bytes</span>(), nil
}
</span></code></pre>

  <p class="en">Writing a server can be similarly simplified using the function</p>
  <p class="zh">使用该函数同样可以简化一个服务器的编写</p>
  <pre>
    <code>
func Listen(net, laddr string) (l Listener, err os.Error)
    </code>
  </pre>

  <p class="en">which returns an object implementing the <code>Listener</code> interface. This interface has a method</p>
  <p class="zh">返回一个实现<code>Listener</code>接口的对象. 该接口有一个方法</p>
  <pre><code>
func (l Listener) Accept() (c Conn, err os.Error)
    </code></pre>

  <p class="en">which will allow a server to be built. Using this, the multi-threaded Echo server given earlier becomes</p>
  <p class="zh">这将允许构建一个服务器。使用它, 将使前面给出的多线程Echo服务器变为</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* ThreadedIPEchoServer
 */
</span><span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"fmt"</span>
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
)

<span class="sgc-2">func</span> main() {

        service := <span class="sgc-3">":1200"</span>
        listener, err := net.<span class="sgc-4">Listen</span>(<span class="sgc-3">"tcp"</span>, service)
        checkError(err)

        <span class="sgc-2">for</span> {
                conn, err := listener.<span class="sgc-4">Accept</span>()
                <span class="sgc-2">if</span> err != nil {
                        <span class="sgc-2">continue</span>
                }
                go handleClient(conn)
        }
}

<span class="sgc-2">func</span> handleClient(conn net.<span class="sgc-4">Conn</span>) {
        defer conn.<span class="sgc-4">Close</span>()

        <span class="sgc-2">var</span> buf [512]<span class="sgc-7">byte</span>
        <span class="sgc-2">for</span> {
                n, err := conn.<span class="sgc-4">Read</span>(buf[0:])
                <span class="sgc-2">if</span> err != nil {
                        <span class="sgc-2">return</span>
                }
                <span class="sgc-6">_</span>, err2 := conn.<span class="sgc-4">Write</span>(buf[0:n])
                <span class="sgc-2">if</span> err2 != nil {
                        <span class="sgc-2">return</span>
                }
        }
}

<span class="sgc-2">func</span> checkError(err error) {
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Fatal error: %s"</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }
}
</span></code></pre>

  <p class="en">If you want to write a UDP server, then there is an interface <code>PacketConn</code> and a method to return an implementation of this:</p>
  <p class="zh">如果你想写一个UDP服务器, 这里有一个<code>PacketConn</code>接口，和一个返回对应实现的方法:</p>
  <pre><code>
func ListenPacket(net, laddr string) (c PacketConn, err os.Error)
    </code></pre>

  <p class="en">This interface has primary methods <code>ReadFrom</code> and <code>WriteTo</code> to handle packet reads and writes.</p>
  <p class="zh">这个接口的主要方法<code>ReadFrom</code>和<code>WriteTo</code>用来处理数据包的读取和写入。</p>

  <p class="en">The Go <code>net</code> package recommends using these interface types rather than the concrete ones. But by using them, you lose specific methods such as <code>SetKeepAlive</code> or <code>TCPConn</code> and <code>SetReadBuffer</code> of <code>UDPConn</code>, unless you do a type cast. It is your choice.</p>
  <p class="zh">Go的<code>net</code>包建议使用接口类型而不是具体的实现类型。但是，通过使用它们，你会失去特有的方法，比如<code>SetKeepAlive</code>或<code>TCPConn</code>和<code>UDPConn</code>的<code>SetReadBuffer</code>，除非你做一个类型转换。如何选择在于你。</p>

  <h2 id="heading_id_29" class="en">Raw sockets and the type IPConn</h2>
  <h2 id="heading_id_29" class="zh">原始套接字和IPConn类型</h2>

  <p class="en">This section covers advanced material which most programmers are unlikely to need. it deals with <em>raw sockets</em>, which allow the programmer to build their own IP protocols, or use protocols other than TCP or UDP</p>
  <p class="zh">本节涵盖了大多数程序员可能需要的高级资料。它涉及<em>raw sockets</em>, ，允许程序员建立自己的IP协议，或使用不同于TCP或UDP的协议。</p>

  <p class="en">TCP and UDP are not the only protocols built above the IP layer. The site http://www.iana.org/assignments/protocol-numbers lists about 140 of them (this list is often available on Unix systems in the file <code>/etc/protocols</code>). TCP and UDP are only numbers 6 and 17 respectively on this list.</p>
  <p class="zh">TCP和UDP并不是建立在IP层之上唯一的协议。该网站：http://www.iana.org/assignments/protocol-numbers 列表上大约有140关于它们(该列表往往在Unix系统的<code>/etc/protocols</code>文件上。)。TCP和UDP在这个名单上分别为6和17。</p>

  <p class="en">Go allows you to build so-called raw sockets, to enable you to communicate using one of these other protocols, or even to build your own. But it gives minimal support: it will connect hosts, and write and read packets between the hosts. In the next chapter we will look at designing and implementing your own protocols above TCP; this section considers the same type of problem, but at the IP layer.</p>
  <p class="zh">Go允许你建立所谓的原始套接字，使你可以使用上述的其中一个协议通信，甚至实现你自己的协议。但它只提供了最低限度的支持: 它会连接主机, 并写入和读取和主机之间的数据包。在下一个章节中，我们将着眼于设计和实现自己的基于TCP之上的协议; 这一小节我们思考同样的问题，不过是在IP层上。</p>

  <p class="en">To keep things simple, we shall use almost the simplest possible example: how to send a ping message to a host. Ping uses the "echo" command from the ICMP protocol. This is a byte-oriented protocol, in which the client sends a stream of bytes to another host, and the host replies. the format is:</p>
  <p class="zh">为了简单起见，我们将使用几乎最简单的例子: 如何发送一个ping消息给主机。Ping使用ICMP协议中的“echo”命令。这是一个面向字节协议, 即客户端发送字节流到另一个主机, 并且目标主机答复字节流。格式如下:</p>

  <ul class="en">
    <li>The first byte is 8, standing for the echo message</li>

    <li>The second byte is zero</li>

    <li>The third and fourth bytes are a checksum on the entire message</li>

    <li>The fifth and sixth bytes are an arbitrary indentifier</li>

    <li>The seventh and eight bytes are an arbitrary sequence number</li>

    <li>The rest of the packet is user data</li>
  </ul>
  <ul class="zh">
    <li>首字节是8, 表示echo消息</li>

    <li>第二个字节是0</li>

    <li>第三和第四字节是整个消息的校验和</li>

    <li>第五和第六字节是一个任意标识</li>

    <li>第七和第八字节是一个任意的序列号</li>

    <li>该数据包的其余部分是用户数据</li>
  </ul>

  <p class="en">The following program will prepare an IP connection, send a ping request to a host and get a reply. You may need to have root access in order to run it successfully.</p>
  <p class="zh">下面的程序将准备一个IP连接，发送一个ping请求到主机，并得到答复。您可能需要root权限才能运行成功。</p>
  <pre><code><span class="sgc-5">
<span class="sgc-1">/* Ping
 */
</span><span class="sgc-2">package</span> main

<span class="sgc-2">import</span> (
        <span class="sgc-3">"bytes"</span>
        <span class="sgc-3">"fmt"</span>
        <span class="sgc-3">"io"</span>
        <span class="sgc-3">"net"</span>
        <span class="sgc-3">"os"</span>
)

<span class="sgc-2">func</span> main() {
        <span class="sgc-2">if</span> len(os.<span class="sgc-4">Args</span>) != 2 {
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Usage: "</span>, os.<span class="sgc-4">Args</span>[0], <span class="sgc-3">"host"</span>)
                os.<span class="sgc-4">Exit</span>(1)
        }

        addr, err := net.<span class="sgc-4">ResolveIPAddr</span>(<span class="sgc-3">"ip"</span>, os.<span class="sgc-4">Args</span>[1])
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Resolution error"</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }

        conn, err := net.<span class="sgc-4">DialIP</span>(<span class="sgc-3">"ip4:icmp"</span>, addr, addr)
        checkError(err)

        <span class="sgc-2">var</span> msg [512]<span class="sgc-7">byte</span>
        msg[0] = 8  <span class="sgc-1">// echo
</span> msg[1] = 0  <span class="sgc-1">// code 0
</span> msg[2] = 0  <span class="sgc-1">// checksum, fix later
</span> msg[3] = 0  <span class="sgc-1">// checksum, fix later
</span> msg[4] = 0  <span class="sgc-1">// identifier[0]
</span> msg[5] = 13 <span class="sgc-1">//identifier[1]
</span> msg[6] = 0  <span class="sgc-1">// sequence[0]
</span> msg[7] = 37 <span class="sgc-1">// sequence[1]
</span> len := 8

        check := checkSum(msg[0:len])
        msg[2] = <span class="sgc-7">byte</span>(check &gt;&gt; 8)
        msg[3] = <span class="sgc-7">byte</span>(check &amp; 255)

        <span class="sgc-6">_</span>, err = conn.<span class="sgc-4">Write</span>(msg[0:len])
        checkError(err)

        <span class="sgc-6">_</span>, err = conn.<span class="sgc-4">Read</span>(msg[0:])
        checkError(err)

        fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Got response"</span>)
        <span class="sgc-2">if</span> msg[5] == 13 {
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"identifier matches"</span>)
        }
        <span class="sgc-2">if</span> msg[7] == 37 {
                fmt.<span class="sgc-4">Println</span>(<span class="sgc-3">"Sequence matches"</span>)
        }

        os.<span class="sgc-4">Exit</span>(0)
}

<span class="sgc-2">func</span> checkSum(msg []<span class="sgc-7">byte</span>) uint16 {
        sum := 0

        <span class="sgc-1">// assume even for now
</span> <span class="sgc-2">for</span> n := 1; n &lt; len(msg)-1; n += 2 {
                sum += <span class="sgc-7">int</span>(msg[n])*256 + <span class="sgc-7">int</span>(msg[n+1])
        }
        sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff)
        sum += (sum &gt;&gt; 16)
        <span class="sgc-2">var</span> answer uint16 = uint16(^sum)
        <span class="sgc-2">return</span> answer
}

<span class="sgc-2">func</span> checkError(err error) {
        <span class="sgc-2">if</span> err != nil {
                fmt.<span class="sgc-4">Fprintf</span>(os.<span class="sgc-4">Stderr</span>, <span class="sgc-3">"Fatal error: %s"</span>, err.<span class="sgc-4">Error</span>())
                os.<span class="sgc-4">Exit</span>(1)
        }
}

<span class="sgc-2">func</span> readFully(conn net.<span class="sgc-4">Conn</span>) ([]<span class="sgc-7">byte</span>, error) {
        defer conn.<span class="sgc-4">Close</span>()

        result := bytes.<span class="sgc-4">NewBuffer</span>(nil)
        <span class="sgc-2">var</span> buf [512]<span class="sgc-7">byte</span>
        <span class="sgc-2">for</span> {
                n, err := conn.<span class="sgc-4">Read</span>(buf[0:])
                result.<span class="sgc-4">Write</span>(buf[0:n])
                <span class="sgc-2">if</span> err != nil {
                        <span class="sgc-2">if</span> err == io.<span class="sgc-4">EOF</span> {
                                <span class="sgc-2">break</span>
                        }
                        <span class="sgc-2">return</span> nil, err
                }
        }
        <span class="sgc-2">return</span> result.<span class="sgc-4">Bytes</span>(), nil
}
</span></code></pre><!--

<h2> Multicast </h2>

<h3> Overview </h3>

<p>
A multicast packet is broadcast to all possible clients,
and may be received by any/all of them. A multicast packet is not
restricted to just one host destination. This is useful for
e.g. multi-player games, or networks where you know a service
is available but don't know its address.
</p>

<p>
IP addresses in the range 224.0.0.0 to 239.255.255.255 (inclusive)
are multicast addresses. 
The address 224.0.0.0 is reserved and should not be used. 
If you <code>ping</code> 224.0.0.1, all multicast-enabled hosts
should answer.
Each of these IP addresses has the full range of 65k ports.
</p>

<p>
"Ordinary" TCP and UDP addresses use a field TTL (time to live)
to control the number of "hops" they are allowed to make.
For example, a hop count of one will restrict them to the local
network.
Multicast packets have the potential to flood the network.
Most network administrators will restrict the range of multicast
packets. The TTL is used for this as a hack measure.
There is no standard, but typically a hopcount of less than 60
will not be allowed past any gateway, and the default hopcount is
usually set at 15.
</p>
-->

  <h2 id="heading_id_30" class="en">Conclusion</h2>
  <h2 id="heading_id_30" class="zh">结论</h2>

  <p class="en">This chapter has considered programming at the IP, TCP and UDP levels. This is often necessary if you wish to implement your own protocol, or build a client or server for an existing protocol.</p>
  <p class="zh">本章着重IP, TCP和UDP级别的编程。如果你想实现自己的协议，或用现有的协议建立一个客户端或服务器，这些内容往往很重要。</p>

  <p class="en">Copyright Jan Newmarch, jan@newmarch.name</p>
  <p class="zh">版权所有 Jan Newmarch, jan@newmarch.name</p>

  <p class="en">If you like this book, please contribute using Flattr <a class="FlattrButton sgc-8" href="http://jan.newmarch.name/go/index.html"></a><br />
  or donate using PayPal</p>

  <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
    <input name="cmd" type="hidden" value="_s-xclick" /> <input name="encrypted" type="hidden" value="-----BEGIN PKCS7-----MIIHLwYJKoZIhvcNAQcEoIIHIDCCBxwCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYCCw7fVj6fuHxYMvE0PBlURcRgBFb1s4TxTUDgsS6BgkdJPt2GF8NFPNvE/oFvPNY2jBGrXSIkxCr9dFYzraKC8csPASWb0z9l8swwbIHWgrvb5cuaVuLbtRzesh94sqyh9MmZ5U1xcMrMtlw1S60gK5lPbKPsXzcY74brjt44J7jELMAkGBSsOAwIaBQAwgawGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQIAXtre9K+AiWAgYiJVN0CmxAPscp0u0O8R0mD+cNz/Fe3lNIrqqMPplkri20WbbVxhbRwJTjtOxcLMbmSIeC8oWh14aSy9Jptgm1wNlQYADQQUgMnR/qIlYgHmXjJ4C6wZteqNVJn+RKfM/tS008Ola5SJABaGe9BmRSQCjMKqEyqm3Mx2hoLeWMXeyoMaW3Xteg6oIIDhzCCA4MwggLsoAMCAQICAQAwDQYJKoZIhvcNAQEFBQAwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMB4XDTA0MDIxMzEwMTMxNVoXDTM1MDIxMzEwMTMxNVowgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDBR07d/ETMS1ycjtkpkvjXZe9k+6CieLuLsPumsJ7QC1odNz3sJiCbs2wC0nLE0uLGaEtXynIgRqIddYCHx88pb5HTXv4SZeuv0Rqq4+axW9PLAAATU8w04qqjaSXgbGLP3NmohqM6bV9kZZwZLR/klDaQGo1u9uDb9lr4Yn+rBQIDAQABo4HuMIHrMB0GA1UdDgQWBBSWn3y7xm8XvVk/UtcKG+wQ1mSUazCBuwYDVR0jBIGzMIGwgBSWn3y7xm8XvVk/UtcKG+wQ1mSUa6GBlKSBkTCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb22CAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQCBXzpWmoBa5e9fo6ujionW1hUhPkOBakTr3YCDjbYfvJEiv/2P+IobhOGJr85+XHhN0v4gUkEDI8r2/rNk1m0GA8HKddvTjyGw/XqXa+LSTlDYkqI8OwR8GEYj4efEtcRpRYBxV8KxAW93YDWzFGvruKnnLbDAF6VR5w/cCMn5hzGCAZowggGWAgEBMIGUMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbQIBADAJBgUrDgMCGgUAoF0wGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTEwNTAyMDcwNzQ1WjAjBgkqhkiG9w0BCQQxFgQUgvHyq74JT8DnmViqEqG5KpIW0cAwDQYJKoZIhvcNAQEBBQAEgYAzycmlaZMZjkmYniVBUVTQeywigBo+80toDP2g9+yCzO4mG1Abmfcr/S1XdT8djFA9w37F+F+nSkP857evscUhns30c9wYuPoiNudkJMOkYegqyq+EI4AMNGPuQNZ+4vznmqTgFTn9iQjONC8NGQ/0GuCCQ/AqJZs/0ZiWivlPhA==-----END PKCS7----- " /> <input alt="PayPal - The safer, easier way to pay online." border="0" name="submit" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_AU/i/btn/btn_donateCC_LG.gif" type="image" /> <img alt="" border="0" height="1" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_AU/i/scr/pixel.gif" width="1" />
  </form>
</body>
</html>
